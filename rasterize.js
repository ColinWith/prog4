/* GLOBAL CONSTANTS AND VARIABLES */

/* assignment specific globals */
//const INPUT_PROG_URL = "https://ncsucgclass.github.io/prog4/";
const INPUT_PROG_URL = "https://colinwith.github.io/prog4/";
const INPUT_TRIANGLES_URL = "https://ncsucgclass.github.io/prog4/triangles.json"; // triangles file loc
const INPUT_ELLIPSOIDS_URL = "https://ncsucgclass.github.io/prog4/ellipsoids.json"; // ellipsoids file loc
//const INPUT_ELLIPSOIDS_URL = null; // ellipsoids file loc
const INPUT_DEFAULT_BACKGROUND_URL = "https://ncsucgclass.github.io/prog4/sky.jpg";
var defaultEye = vec3.fromValues(0.5, 0.5, -0.5); // default eye position in world space
var defaultCenter = vec3.fromValues(0.5,0.5,0.5); // default view direction in world space
var defaultUp = vec3.fromValues(0,1,0); // default view up vector
var lightAmbient = vec3.fromValues(1,1,1); // default light ambient emission
var lightDiffuse = vec3.fromValues(1,1,1); // default light diffuse emission
var lightSpecular = vec3.fromValues(1,1,1); // default light specular emission
var lightPosition = vec3.fromValues(-0.5,1.5,-0.5); // default light position

/* webgl and geometry data */
var gl = null; // the all powerful gl object. It's all here folks!
var inputTriangles = []; // the triangle data as loaded from input files
var sortedInputTriangles = []; // the order of inputTriangle indexes to render
var numTriangleSets = 0; // how many triangle sets in input scene
var inputEllipsoids = []; // the ellipsoid data as loaded from input files
var numEllipsoids = 0; // how many ellipsoids in the input scene
var vertexBuffers = []; // this contains vertex coordinate lists by set, in triples
var normalBuffers = []; // this contains normal component lists by set, in triples
var uvBuffers = []; // this contains UVcoord component lists by set, in triples
var textures = []; // list of textures
var numTextures = 0;
var numOpaqueObjects = 0;
var numTransparentObjects = 0;
var triSetSizes = []; // this contains the size of each triangle set
var triangleBuffers = []; // lists of indices into vertexBuffers by set, in triples
var viewDelta = 0; // how much to displace view when moving
var viewDeltaModifier = 1; // 100 by default (smaller = greater displacement)
var rotateTheta = Math.PI; // how much to rotate models by
var deltaTime = 0;
var deltaTimeMS = 0;
var thenTime = 0;
var timeModifier = 1;

var lerpAlpha = 0.0;
var reverseLerp = false;

/* objects */
const objectTypeEnum = { PLAYER_A: 1, PLAYER_B: 2, ENEMY_A: 3, ENEMY_B: 4, PLAYER_PROJECTILE: 5, ENEMY_PROJECTILE: 6, PROP: 7 }; // enumerated object types

/* shader parameter locations */
var vPosAttribLoc; // where to put position for vertex shader
var vNormAttribLoc; // where to put normal for vertex shader
var vUVAttribLoc; // where to put texture for fragment shader
var mMatrixULoc; // where to put model matrix for vertex shader
var pvmMatrixULoc; // where to put project model view matrix for vertex shader
var ambientULoc; // where to put ambient reflecivity for fragment shader
var diffuseULoc; // where to put diffuse reflecivity for fragment shader
var specularULoc; // where to put specular reflecivity for fragment shader
var shininessULoc; // where to put specular exponent for fragment shader
var alphaULoc; // where to put alpha value for fragment shader
var textureIDULoc; // where to put textureID value for fragment shader
var hasTextureULoc; // where to put whether or not the fragment shader should load a texture
var modulateTexULoc; // where to put whether or not the fragment shader should blend texture colors with lighting

/* interaction variables */
var Eye = vec3.clone(defaultEye); // eye position in world space
var Center = vec3.clone(defaultCenter); // view direction in world space
var Up = vec3.clone(defaultUp); // view up vector in world space
var worldUp = vec3.fromValues(0.0, 1.0, 0.0);

/* gameObjects */
var objectList = [];
var playerModelsA = [];
var playerModelsB = [];
var enemyModelsA = [];
var enemyModelsB = [];
var playerProjectiles = [];
var enemyProjectiles = [];
var numEnemies = 0;
var numObjects = 0;

/* gameState */
var gameWon = false;
var gameLost = false;
var numEnemiesDestroyed = 0;
var debugMode = true;


/* input key values */
/* 0 = not pressed, 1 = pressed, 2 = initial press, -1 = released */
var inputKeys = {
    Space: 0,
    Shift: 0,
    ArrowRight: 0, ArrowLeft: 0, ArrowUp: 0, ArrowDown: 0,
    KeyA: 0, KeyD: 0, KeyS: 0, KeyW: 0,
    KeyQ: 0,
    KeyE: 0,
    Escape: 0,
    KeyB: 0,
    Digit1: 0,
    KeyK: 0,
    Semicolon: 0,
    KeyL: 0,
    KeyO: 0,
    KeyI: 0,
    KeyP: 0,
    Backspace: 0,
    Minus: 0,
    Equal: 0
};

var showTriangles = true;
var showEllispoids = false;
var enableBackFaceCull = true;
var isPlayerShooting = false;
var playerShootTimer = 0;
var isEnemyShooting = false;
var enemyAttackTimer = 0;
var enemyShootTimer = 0;
var enemyDiveTimer = 0;
var enemyDiverIdx = 0;
var enemyDiveDirection = vec3.fromValues(0, 0, 0);
var enemyShootDirection = vec3.fromValues(0, 0, 0);
var diveEvent = false;

var toggleBlendingLightingMode = true;
var useAcceleration = true;

/* custom content */
var customInputTriangles = [];
var testInputTriangles = [
    /*{
        "material": { "ambient": [0.1, 0.1, 0.1], "diffuse": [0.4639, 0.5718, 0.2496], "specular": [0.6, 0.6, 0.6], "n": 5, "alpha": 0.99, "texture": "abe.png" },
        "vertices": [[0.45, -0.05, 0.25], [0.55, -0.05, 0.25], [0.5, 0.05, 0.25]],
        "normals": [[0.0, 0.0, -1.0], [0.0, 0.0, -1.0], [0.0, 0.0, -1.0]],
        "uvs": [[0.5, 1], [1, 0], [0, 0]],
        "triangles": [[0, 2, 1]],
        "type": 1,
        "count": 1,
        "parent": -1,
        "children": [1],
        "visible": true,
        "active": true
    },
    */
    {
        "material": { "ambient": [0.1, 0.1, 0.1], "diffuse": [0.4639, 0.5718, 0.2496], "specular": [0.6, 0.6, 0.6], "n": 5, "alpha": 1.0, "texture": "retro.jpg" },
        "vertices": [
            [
                0.5021001100540161,
                0.11772000789642334,
                0.22342906892299652
            ],
            [
                0.4695501923561096,
                -0.11197510361671448,
                0.24272650480270386
            ],
            [
                0.5010501742362976,
                0.11157990247011185,
                0.25518709421157837
            ],
            [
                0.4706002175807953,
                -0.11385994404554367,
                0.2648647725582123
            ],
            [
                0.4811001121997833,
                0.04912370815873146,
                0.1882263869047165
            ],
            [
                0.4811001420021057,
                0.012681644409894943,
                0.19697628915309906
            ],
            [
                0.47900015115737915,
                0.04802370443940163,
                0.24185767769813538
            ],
            [
                0.4802601635456085,
                0.005130955949425697,
                0.21933136880397797
            ],
            [
                0.46724018454551697,
                -0.03070884197950363,
                0.24381977319717407
            ],
            [
                0.46829017996788025,
                -0.03414291515946388,
                0.2639157772064209
            ],
            [
                0.4811001718044281,
                -0.035874705761671066,
                0.24611899256706238
            ],
            [
                0.4811001718044281,
                -0.03348987549543381,
                0.22606313228607178
            ],
            [
                0.5000001788139343,
                0.07997719198465347,
                0.2805640995502472
            ],
            [
                0.47165021300315857,
                -0.0895916149020195,
                0.2702406942844391
            ],
            [
                0.4811002016067505,
                -0.04060421511530876,
                0.2872799336910248
            ],
            [
                0.4769001603126526,
                0.0743723213672638,
                0.25766170024871826
            ],
            [
                0.47480013966560364,
                0.08283171057701111,
                0.23159414529800415
            ],
            [
                0.4811001718044281,
                0.04811612889170647,
                0.28546103835105896
            ],
            [
                0.4795251190662384,
                0.008226080797612667,
                0.1975208967924118
            ],
            [
                0.4771101176738739,
                0.05363132432103157,
                0.1868518441915512
            ],
            [
                0.4690251648426056,
                0.042639296501874924,
                0.23707257211208344
            ],
            [
                0.4706001579761505,
                0.03165625408291817,
                0.26034706830978394
            ],
            [
                0.4800501763820648,
                0.015862274914979935,
                0.2869579792022705
            ],
            [
                0.5315002202987671,
                -0.11226522922515869,
                0.24063603579998016
            ],
            [
                0.5294002294540405,
                -0.11448945105075836,
                0.26488882303237915
            ],
            [
                0.5183751583099365,
                0.049123719334602356,
                0.1882263720035553
            ],
            [
                0.5187951326370239,
                0.012681655585765839,
                0.19697627425193787
            ],
            [
                0.5210001468658447,
                0.04802371561527252,
                0.24185766279697418
            ],
            [
                0.5196351408958435,
                0.005163087975233793,
                0.2201707363128662
            ],
            [
                0.5189002156257629,
                -0.03587469458580017,
                0.24611896276474
            ],
            [
                0.5178501605987549,
                -0.034498948603868484,
                0.227152481675148
            ],
            [
                0.5204751491546631,
                0.008226092904806137,
                0.1975208818912506
            ],
            [
                0.5215251445770264,
                0.05258210748434067,
                0.18689197301864624
            ],
            [
                0.4811001121997833,
                0.04912370815873146,
                0.1882263869047165
            ],
            [
                0.4811001420021057,
                0.012681644409894943,
                0.19697628915309906
            ],
            [
                0.47900015115737915,
                0.04802370443940163,
                0.24185767769813538
            ],
            [
                0.4802601635456085,
                0.005130955949425697,
                0.21933136880397797
            ],
            [
                0.4811001718044281,
                -0.035874705761671066,
                0.24611899256706238
            ],
            [
                0.4811001718044281,
                -0.03348987549543381,
                0.22606313228607178
            ],
            [
                0.5183751583099365,
                0.049123719334602356,
                0.1882263720035553
            ],
            [
                0.5187951326370239,
                0.012681655585765839,
                0.19697627425193787
            ],
            [
                0.5210001468658447,
                0.04802371561527252,
                0.24185766279697418
            ],
            [
                0.5196351408958435,
                0.005163087975233793,
                0.2201707363128662
            ],
            [
                0.5189002156257629,
                -0.03587469458580017,
                0.24611896276474
            ],
            [
                0.5178501605987549,
                -0.034498948603868484,
                0.227152481675148
            ],
            [
                0.5021001100540161,
                0.11772000789642334,
                0.22342906892299652
            ],
            [
                0.4695501923561096,
                -0.11197510361671448,
                0.24272650480270386
            ],
            [
                0.46724018454551697,
                -0.03070884197950363,
                0.24381977319717407
            ],
            [
                0.47480013966560364,
                0.08283171057701111,
                0.23159414529800415
            ],
            [
                0.4690251648426056,
                0.042639296501874924,
                0.23707257211208344
            ],
            [
                0.5315002202987671,
                -0.11226522922515869,
                0.24063603579998016
            ],
            [
                0.5325502157211304,
                -0.03102359175682068,
                0.2438317835330963
            ],
            [
                0.5252001285552979,
                0.08241203427314758,
                0.23161017894744873
            ],
            [
                0.5309751629829407,
                0.042849164456129074,
                0.23706451058387756
            ],
            [
                0.5021001100540161,
                0.11772000789642334,
                0.22342906892299652
            ],
            [
                0.5010501742362976,
                0.11157990247011185,
                0.25518709421157837
            ],
            [
                0.5000001788139343,
                0.07997719198465347,
                0.2805640995502472
            ],
            [
                0.5315002202987671,
                -0.11226522922515869,
                0.24063603579998016
            ],
            [
                0.5294002294540405,
                -0.11448945105075836,
                0.26488882303237915
            ],
            [
                0.5325502157211304,
                -0.03102359175682068,
                0.2438317835330963
            ],
            [
                0.5315002202987671,
                -0.03414289653301239,
                0.2639157474040985
            ],
            [
                0.5294002294540405,
                -0.08963175117969513,
                0.2691914439201355
            ],
            [
                0.5178502202033997,
                -0.04165343940258026,
                0.287320077419281
            ],
            [
                0.5231001377105713,
                0.07437232881784439,
                0.2576616704463959
            ],
            [
                0.5252001285552979,
                0.08241203427314758,
                0.23161017894744873
            ],
            [
                0.5189001560211182,
                0.04916536808013916,
                0.28542086482048035
            ],
            [
                0.5309751629829407,
                0.042849164456129074,
                0.23706451058387756
            ],
            [
                0.5294001698493958,
                0.03165626898407936,
                0.26034703850746155
            ],
            [
                0.5199502110481262,
                0.01565244048833847,
                0.2869659960269928
            ],
            [
                0.4802601635456085,
                -0.03126903995871544,
                0.2025313824415207
            ],
            [
                0.4811002016067505,
                -0.035339366644620895,
                0.246108740568161
            ],
            [
                0.4811001718044281,
                -0.033489879220724106,
                0.20086312294006348
            ],
            [
                0.5189002156257629,
                -0.0353393629193306,
                0.246108740568161
            ],
            [
                0.5173601508140564,
                -0.03126903995871544,
                0.20393137633800507
            ],
            [
                0.5173601508140564,
                -0.03126903995871544,
                0.20393137633800507
            ],
            [
                0.5161001682281494,
                -0.033489879220724106,
                0.20226313173770905
            ],
            [
                0.4811001718044281,
                -0.033489882946014404,
                0.20156311988830566
            ],
            [
                0.5161001682281494,
                -0.033489879220724106,
                0.20296312868595123
            ],
            [
                0.4802601635456085,
                -0.03126903995871544,
                0.2025313824415207
            ],
            [
                0.4811001718044281,
                -0.036989882588386536,
                0.20086312294006348
            ],
            [
                0.4811001718044281,
                0.01621011458337307,
                0.20156311988830566
            ],
            [
                0.5161001682281494,
                -0.03698987886309624,
                0.20226313173770905
            ],
            [
                0.5189001560211182,
                0.01621011458337307,
                0.20226311683654785
            ]
        ],
        "normals": [
            [-0.08115844428539276,0.06585825979709625,0.01004982739686966],
            [-0.07555100321769714,-0.0728670284152031,-0.002728506224229932],
            [-0.08081675320863724,0.060271333903074265,0.029343141242861748],
            [-0.07547829300165176,-0.07299332320690155,3.334156281198375e-05],
            [-2.9548701263593102e-08,0.10497792065143585,0.0021531465463340282],
            [1.0582033027617399e-08,-0.0994788184762001,-0.033600110560655594],
            [-2.954870836902046e-08,0.10497792810201645,0.002153141424059868],
            [0.001454346813261509,-0.06863635033369064,-0.07944770902395248],
            [-0.1048300638794899,0.0008630558731965721,0.005908837076276541],
            [-0.10136768221855164,0.00015621230704709888,0.027378270402550697],
            [-0.0017370553687214851,-0.10441412031650543,-0.010939589701592922],
            [1.9570121366996318e-05,-0.07479545474052429,-0.07369288057088852],
            [
                -0.07073365896940231,
                0.05039238929748535,
                0.059011511504650116
            ],
            [
                -0.09927947074174881,
                -0.002124200575053692,
                0.034118544310331345
            ],
            [
                -0.09213678538799286,
                -0.0005894889472983778,
                0.05035340413451195
            ],
            [
                -0.09102463722229004,
                0.03833959251642227,
                0.03563136234879494
            ],
            [
                -0.09302546828985214,
                0.04530233517289162,
                0.017859436571598053
            ],
            [
                -0.09354604035615921,
                0.022898435592651367,
                0.04183061793446541
            ],
            [
                -0.00023333313583862036,
                -0.02425914816558361,
                -0.10215889662504196
            ],
            [
                -0.0004756009439006448,
                -0.024041855707764626,
                -0.1022094115614891
            ],
            [
                -0.10356350243091583,
                0.01203701738268137,
                0.012438328936696053
            ],
            [
                -0.10208260267972946,
                0.008461699821054935,
                0.023076873272657394
            ],
            [
                -0.09705313295125961,
                0.004226794932037592,
                0.03984750807285309
            ],
            [
                -0.0008155805990099907,
                -0.10455162823200226,
                -0.009658935479819775
            ],
            [
                -0.000880152452737093,
                -0.10456690192222595,
                -0.009486316703259945
            ],
            [
                -2.9548703039949942e-08,
                0.10497792065143585,
                0.0021531428210437298
            ],
            [
                0.0005079294205643237,
                -0.09973997622728348,
                -0.03281279280781746
            ],
            [
                -2.954870659266362e-08,
                0.10497792065143585,
                0.0021531367674469948
            ],
            [
                0.0018454715609550476,
                -0.0686589926481247,
                -0.07942001521587372
            ],
            [
                2.6470370784181796e-08,
                -0.10472486168146133,
                -0.007596283685415983
            ],
            [
                0.0010823204647749662,
                -0.07871251553297043,
                -0.06948503106832504
            ],
            [
                -4.9193122464430417e-08,
                -0.024468157440423965,
                -0.10210929065942764
            ],
            [
                -0.000257291627349332,
                -0.024237671867012978,
                -0.10216393321752548
            ],
            [
                -0.10491412878036499,
                -0.0009912776295095682,
                -0.0041283187456429005
            ],
            [
                -0.10491278767585754,
                -0.0009297994547523558,
                -0.004176665563136339
            ],
            [
                -0.10494436323642731,
                -0.0015032103983685374,
                -0.0030694839078933
            ],
            [
                -0.10496082901954651,
                -0.0018935116240754724,
                -0.002154196612536907
            ],
            [
                -0.10497017204761505,
                -0.002458064816892147,
                -0.00047097730566747487
            ],
            [
                -0.10497374832630157,
                -0.0023315371945500374,
                -0.00027718019555322826
            ],
            [
                0.10487443953752518,
                -2.3873739337432198e-05,
                -0.00513366237282753
            ],
            [
                0.10489320009946823,
                -0.0005761155625805259,
                -0.004699724726378918
            ],
            [
                0.10492921620607376,
                -0.0011848368449136615,
                -0.003668216522783041
            ],
            [
                0.10493216663599014,
                -0.002378367818892002,
                -0.0029296870343387127
            ],
            [
                0.10479918867349625,
                -0.004704535938799381,
                -0.004471939522773027
            ],
            [
                0.10465510189533234,
                -0.005804002285003662,
                -0.006214858032763004
            ],
            [
                -0.00016568167484365404,
                -0.023804165422916412,
                -0.10226599127054214
            ],
            [
                -0.001995751168578863,
                0.0029859652277082205,
                -0.1049385666847229
            ],
            [
                -6.225902211554057e-07,
                -0.004132572095841169,
                -0.10491865873336792
            ],
            [
                -0.00011348696716595441,
                -0.017583489418029785,
                -0.10351719707250595
            ],
            [
                -1.6756990589783527e-05,
                -0.011789103038609028,
                -0.10433608293533325
            ],
            [
                -0.0035188510082662106,
                0.004170207306742668,
                -0.10485813021659851
            ],
            [
                -0.0007315452676266432,
                -0.0034916377626359463,
                -0.10493937879800797
            ],
            [
                -6.62742750137113e-05,
                -0.017781460657715797,
                -0.1034834086894989
            ],
            [
                2.6513009288464673e-05,
                -0.011835230514407158,
                -0.10433085262775421
            ],
            [
                0.0855022519826889,
                0.05924856290221214,
                0.01428197044879198
            ],
            [
                0.08353801816701889,
                0.055083245038986206,
                0.031815651804208755
            ],
            [
                0.07103157788515091,
                0.04929051548242569,
                0.05958154797554016
            ],
            [
                0.104645274579525,
                -0.002462746575474739,
                0.008264557458460331
            ],
            [
                0.1045389175415039,
                -0.002617532853037119,
                0.009474397636950016
            ],
            [
                0.1048232913017273,
                0.0012723555555567145,
                0.0059546311385929585
            ],
            [
                0.10104790329933167,
                0.0003733456542249769,
                0.028533877804875374
            ],
            [
                0.10289888083934784,
                -0.001915467786602676,
                0.020812327042222023
            ],
            [
                0.09077822417020798,
                -0.0005625066696666181,
                0.052763622254133224
            ],
            [
                0.0915793776512146,
                0.03723979368805885,
                0.035375386476516724
            ],
            [
                0.09449226409196854,
                0.04213031008839607,
                0.017923472449183464
            ],
            [
                0.09349101781845093,
                0.023598602041602135,
                0.04156365990638733
            ],
            [
                0.10356687754392624,
                0.012015086598694324,
                0.012431378476321697
            ],
            [
                0.10212945193052292,
                0.008207932114601135,
                0.022960973903536797
            ],
            [
                0.09695377200841904,
                0.0037525761872529984,
                0.04013584554195404
            ],
            [
                -0.09856247901916504,
                -0.036169782280921936,
                -0.0014784685336053371
            ],
            [
                -0.09856248646974564,
                -0.03616977855563164,
                -0.0014784688828513026
            ],
            [
                -0.04689395800232887,
                -0.09394393116235733,
                -0.0007034700247459114
            ],
            [
                0.09351637959480286,
                -0.047078222036361694,
                -0.00795788411051035
            ],
            [
                0.09093895554542542,
                -0.004786282777786255,
                -0.05227043479681015
            ],
            [
                0.09351638704538345,
                -0.04707822576165199,
                -0.007957885041832924
            ],
            [
                0.04163531959056854,
                -0.0963272899389267,
                -0.003543050726875663
            ],
            [
                5.990756779539197e-09,
                -0.10500000417232513,
                -6.239859828838235e-08
            ],
            [
                5.990758999985246e-09,
                -0.10499999672174454,
                -6.239859828838235e-08
            ],
            [
                -0.092876136302948,
                0.0006444041500799358,
                -0.04897558316588402
            ],
            [
                -0.0928761437535286,
                0.0006444041500799358,
                -0.048975586891174316
            ],
            [
                -0.0928761437535286,
                0.0006444041500799358,
                -0.04897559434175491
            ],
            [
                0.09093895554542542,
                -0.004786282777786255,
                -0.05227043479681015
            ],
            [
                0.09093895554542542,
                -0.0047862837091088295,
                -0.05227043852210045
            ]
        ],
        "uvs": [[0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0], [0.5, 1], [1, 0], [0, 0],],
        "triangles": [
            [
                21,
                8,
                9
            ],
            [
                63,
                66,
                64
            ],
            [
                49,
                48,
                52
            ],
            [
                9,
                1,
                3
            ],
            [
                49,
                53,
                51
            ],
            [
                9,
                13,
                14
            ],
            [
                9,
                22,
                21
            ],
            [
                65,
                67,
                63
            ],
            [
                15,
                12,
                2
            ],
            [
                2,
                16,
                15
            ],
            [
                7,
                26,
                28
            ],
            [
                1,
                24,
                3
            ],
            [
                18,
                32,
                31
            ],
            [
                10,
                30,
                29
            ],
            [
                6,
                25,
                4
            ],
            [
                21,
                17,
                15
            ],
            [
                15,
                20,
                21
            ],
            [
                46,
                47,
                51
            ],
            [
                48,
                45,
                52
            ],
            [
                49,
                52,
                53
            ],
            [
                55,
                64,
                54
            ],
            [
                56,
                63,
                55
            ],
            [
                68,
                60,
                67
            ],
            [
                11,
                28,
                30
            ],
            [
                21,
                20,
                8
            ],
            [
                9,
                8,
                1
            ],
            [
                49,
                51,
                47
            ],
            [
                9,
                3,
                13
            ],
            [
                9,
                14,
                22
            ],
            [
                60,
                61,
                58
            ],
            [
                15,
                17,
                12
            ],
            [
                2,
                0,
                16
            ],
            [
                7,
                5,
                26
            ],
            [
                1,
                23,
                24
            ],
            [
                10,
                11,
                30
            ],
            [
                6,
                27,
                25
            ],
            [
                21,
                22,
                17
            ],
            [
                15,
                16,
                20
            ],
            [
                46,
                51,
                50
            ],
            [
                60,
                57,
                59
            ],
            [
                67,
                59,
                66
            ],
            [
                11,
                7,
                28
            ],
            [
                34,
                35,
                33
            ],
            [
                34,
                36,
                35
            ],
            [
                36,
                37,
                35
            ],
            [
                40,
                39,
                41
            ],
            [
                40,
                41,
                42
            ],
            [
                43,
                42,
                41
            ],
            [
                36,
                38,
                37
            ],
            [
                43,
                44,
                42
            ],
            [
                67,
                60,
                59
            ],
            [
                60,
                58,
                57
            ],
            [
                60,
                62,
                61
            ],
            [
                68,
                62,
                60
            ],
            [
                56,
                65,
                63
            ],
            [
                55,
                63,
                64
            ],
            [
                65,
                68,
                67
            ],
            [
                63,
                67,
                66
            ],
            [
                18,
                19,
                32
            ],
            [
                69,
                71,
                70
            ],
            [
                73,
                81,
                82
            ],
            [
                74,
                72,
                75
            ],
            [
                75,
                77,
                76
            ],
            [
                75,
                76,
                71
            ],
            [
                78,
                80,
                79
            ]
        ],
        "type": 1,
        "count": 1,
        "parent": -1,
        "children": [1],
        "visible": true,
        "active": true
    },
    {
        "material": { "ambient": [0.1, 0.1, 0.1], "diffuse": [0.4639, 0.5718, 0.2496], "specular": [0.6, 0.6, 0.6], "n": 5, "alpha": 0.99, "texture": "abe.png" },
        "vertices": [[0.45, -0.05, 0.25], [0.55, -0.05, 0.25], [0.5, 0.04, 0.25]],
        "normals": [[0.0, 0.0, -1.0], [0.0, 0.0, -1.0], [0.0, 0.0, -1.0]],
        "uvs": [[0.5, 1], [1, 0], [0, 0]],
        "triangles": [[0, 2, 1]],
        "type": 2,
        "count": 1,
        "parent": 0,
        "children": [],
        "visible": false,
        "active": true
    },
    {
        "material": { "ambient": [0.1, 0.1, 0.1], "diffuse": [0.8000, 0.2126, 0.1469], "specular": [0.6, 0.6, 0.6], "n": 5, "alpha": 0.99, "texture": "MyHand1_square.png" },
        //"vertices": [[1.05, 1.10, 0.25], [0.95, 1.10, 0.25], [0.95, 1.0, 0.25], [1.05, 1.0, 0.25]],
        "vertices": [[1.05, 1.05, 0.15], [0.95, 1.05, 0.15], [0.95, 1.05, 0.25], [1.05, 1.05, 0.25]],
        "normals": [[0.0, 0.0, -1.0], [0.0, 0.0, -1.0], [0.0, 0.0, -1.0], [0.0, 0.0, -1.0]],
        "uvs": [[1, 0], [0, 0], [0, 1], [1, 1]],
        "triangles": [[0, 2, 1], [0, 3, 2]],
        "type": 3,
        "count": 12,
        "parent": -1,
        "children": [3],
        "visible": true,
        "active": true
    },
    {
        "material": { "ambient": [0.1, 0.1, 0.1], "diffuse": [0.8000, 0.2126, 0.1469], "specular": [0.6, 0.6, 0.6], "n": 5, "alpha": 0.99, "texture": "MyHand1_square.png" },
        //"vertices": [[1.05, 1.075, 0.25], [0.95, 1.075, 0.25], [0.95, 1.0, 0.25], [1.05, 1.0, 0.25]],
        "vertices": [[1.05, 1.05, 0.175], [0.95, 1.05, 0.175], [0.95, 1.05, 0.25], [1.05, 1.05, 0.25]],
        "normals": [[0.0, 0.0, -1.0], [0.0, 0.0, -1.0], [0.0, 0.0, -1.0], [0.0, 0.0, -1.0]],
        "uvs": [[1, 0], [0, 0], [0, 1], [1, 1]],
        "triangles": [[0, 2, 1], [0, 3, 2]],
        "type": 4,
        "count": 12,
        "parent": 2,
        "children": [],
        "visible": false,
        "active": true
    },
    {
        "material": { "ambient": [0.1, 0.1, 0.1], "diffuse": [0.4639, 0.5718, 0.2496], "specular": [0.6, 0.6, 0.6], "n": 5, "alpha": 0.99, "texture": "abe.png" },
        "vertices": [[0.475, -0.05, 0.25], [0.525, -0.05, 0.25], [0.5, 0.05, 0.25]],
        "normals": [[0.0, 0.0, -1.0], [0.0, 0.0, -1.0], [0.0, 0.0, -1.0]],
        "uvs": [[0.5, 1], [1, 0], [0, 0]],
        "triangles": [[0, 2, 1]],
        "type": 5,
        "count": 1,
        "parent": -1,
        "children": [],
        "visible": false,
        "active": true
    },
    {
        "material": { "ambient": [0.1, 0.1, 0.1], "diffuse": [0.7, 0.2, 0.2496], "specular": [0.6, 0.6, 0.6], "n": 5, "alpha": 0.99, "texture": "tree.png" },
        "vertices": [[0.525, 0.25, 0.25], [0.475, 0.25, 0.25], [0.5, 0.15, 0.25]],
        "normals": [[0.0, 0.0, -1.0], [0.0, 0.0, -1.0], [0.0, 0.0, -1.0]],
        "uvs": [[0.5, 1], [1, 0], [0, 0]],
        "triangles": [[0, 2, 1]],
        "type": 6,
        "count": 1,
        "parent": -1,
        "children": [],
        "visible": false,
        "active": true
    }
];

var useCustomInput = false;



// ASSIGNMENT HELPER FUNCTIONS

// get the JSON file from the passed URL
function getJSONFile(url,descr) {
    try {
        if ((typeof(url) !== "string") || (typeof(descr) !== "string"))
            throw "getJSONFile: parameter not a string";
        else {
            var httpReq = new XMLHttpRequest(); // a new http request
            httpReq.open("GET",url,false); // init the request
            httpReq.send(null); // send the request
            var startTime = Date.now();
            while ((httpReq.status !== 200) && (httpReq.readyState !== XMLHttpRequest.DONE)) {
                if ((Date.now()-startTime) > 3000)
                    break;
            } // until its loaded or we time out after three seconds
            if ((httpReq.status !== 200) || (httpReq.readyState !== XMLHttpRequest.DONE))
                throw "Unable to open "+descr+" file!";
            else
                return JSON.parse(httpReq.response); 
        } // end if good params
    } // end try    
    
    catch(e) {
        console.log(e);
        return(String.null);
    }
} // end get input json file

/**
 * translate given model
 * @param {any} model to translate
 * @param {any} offset to translate by
 */
function translateModel(model, offset) {
    if (model != null) {
        //model.velocity[]
        vec3.add(model.translation, model.translation, vec3.scale(vec3.create(), offset, deltaTime));
    }
} // end translate model

/**
 * Set position of given model to the given vec3 coordinates
 * @param {any} model to translate
 * @param {any} transform to translate to
 * @param {bool} relativeToWold whether or not the position is relative to the models center or the world center
 */
function setModelPosition(model, transform, relativeToWold) {
    if (model != null && transform != null) {
        var temp = vec3.create();
        if (relativeToWold) {
            model.translation = vec3.negate(temp, model.center);
        }
        else {
            model.translation = vec3.fromValues(0.0, 0.0, 0.0);
        }
        vec3.add(model.translation, model.translation, transform);

    }
    else {
        console.log("Can not set model positon!");
    }
}

/**
 * Translates the camera view by the gien offset
 * @param {any} axis
 * @param {any} offset
 */
//function translateView(axis, offset) {
//    Center = vec3.add(Center, Center, vec3.scale(temp, viewRight, -(offset * deltaTime)));
//    if (!(inputKeys.Shift > 0)) {
//        Eye = vec3.add(Eye, Eye, vec3.scale(temp, viewRight, -(offset * deltaTime)));
//    }
//}

/** 
 * Rotate given model on an axis by a given amount
 * @param {any} model to rotate
 * @param {any} axis to rotate around
 * @param {any} rotateAmount to rotate in
 */
function rotateModel(model, axis, rotateAmount) {
    if (model != null) {
        var newRotation = mat4.create();

        mat4.fromRotation(newRotation, rotateAmount * deltaTime, axis); // get a rotation matrix around passed axis
        vec3.transformMat4(model.xAxis, model.xAxis, newRotation); // rotate model x axis tip
        vec3.transformMat4(model.yAxis, model.yAxis, newRotation); // rotate model y axis tip
    } // end if there is a highlighted model
} // end rotate model

/**
 * fires the player's projectile from the players current position
 */
function playerFire() {

    if (!isPlayerShooting) {
        isPlayerShooting = true;
        playerProjectiles[0].visible = true;
        setModelPosition(playerProjectiles[0], playerModelsA[0].translation, false);
        console.log("fire!");
    }
    
}

/**
 * Fires the enemy's projectile from the given enemy's position
 */
function enemyFire(enemy) {
    enemyAttackTimer = 0;
    isEnemyShooting = true;
    enemyProjectiles[0].visible = true;
    setModelPosition(enemyProjectiles[0], vec3.add(vec3.create(), enemy.center, enemy.translation), true);
    //setModelRotation(enemyProjectiles[0], );

    console.log("(enemy) fire!");

}

/** 
 * Does stuff when keys are pressed down
 */
function handleKeyDown(event) {
    
    const modelEnum = {TRIANGLES: "triangles", ELLIPSOID: "ellipsoid"}; // enumerated model type
    const dirEnum = {NEGATIVE: -1, POSITIVE: 1}; // enumerated rotation direction

    // cycle through models, highlighting the selected one
    function highlightModel(modelType,whichModel) {
        if (handleKeyDown.modelOn != null)
            handleKeyDown.modelOn.on = false;
        handleKeyDown.whichOn = whichModel;
        if (modelType == modelEnum.TRIANGLES)
            handleKeyDown.modelOn = inputTriangles[whichModel]; 
        else
            handleKeyDown.modelOn = inputEllipsoids[whichModel]; 
        handleKeyDown.modelOn.on = true; 
    } // end highlight model
    
    // set up needed view params
    var lookAt = vec3.create(), viewRight = vec3.create(), temp = vec3.create(); // lookat, right & temp vectors
    lookAt = vec3.normalize(lookAt,vec3.subtract(temp,Center,Eye)); // get lookat vector
    viewRight = vec3.normalize(viewRight,vec3.cross(temp,lookAt,Up)); // get view right vector
    
    // highlight static variables
    handleKeyDown.whichOn = handleKeyDown.whichOn == undefined ? -1 : handleKeyDown.whichOn; // nothing selected initially
    handleKeyDown.modelOn = handleKeyDown.modelOn == undefined ? null : handleKeyDown.modelOn; // nothing selected initially

    if (!event.getModifierState("Shift")) {
        inputKeys.Shift = 0;
    }
    else {
        inputKeys.Shift = 1;
    }

    switch (event.code) {
        
        // model selection
        case "Space": 
            if (inputKeys.Space > 0) { // if key is already pressed
                inputKeys.Space = 1;
            }
            else {
                inputKeys.Space = 2;
            }
            if (handleKeyDown.modelOn != null) {
                handleKeyDown.modelOn.on = false; // turn off highlighted model
                handleKeyDown.modelOn = null; // no highlighted model
                handleKeyDown.whichOn = -1; // nothing highlighted
            }
            break;
        case "Shift":
            if (inputKeys.Shift > 0) { // if key is already pressed
                inputKeys.Shift = 1;
            }
            else {
                inputKeys.Shift = 2;
            }
            break;
        case "ArrowRight": // select next triangle set
            if (inputKeys.ArrowRight > 0) { // if key is already pressed
                inputKeys.ArrowRight = 1;
            }
            else {
                inputKeys.ArrowRight = 2;
            }
            //highlightModel(modelEnum.TRIANGLES,(handleKeyDown.whichOn+1) % numTriangleSets);
            break;
        case "ArrowLeft": // select previous triangle set
            if (inputKeys.ArrowLeft > 0) { // if key is already pressed
                inputKeys.ArrowLeft = 1;
            }
            else {
                inputKeys.ArrowLeft = 2;
            }
            //highlightModel(modelEnum.TRIANGLES, (handleKeyDown.whichOn > 0) ? handleKeyDown.whichOn - 1 : numTriangleSets - 1);
            break;
        case "ArrowUp": // select next ellipsoid
            if (inputKeys.ArrowUp > 0) { // if key is already pressed
                inputKeys.ArrowUp = 1;
            }
            else {
                inputKeys.ArrowUp = 2;
            }
            //highlightModel(modelEnum.ELLIPSOID, (handleKeyDown.whichOn + 1) % numEllipsoids);
            break;
        case "ArrowDown": // select previous ellipsoid
            if (inputKeys.ArrowDown > 0) { // if key is already pressed
                inputKeys.ArrowDown = 1;
            }
            else {
                inputKeys.ArrowDown = 2;
            }
            //highlightModel(modelEnum.ELLIPSOID, (handleKeyDown.whichOn > 0) ? handleKeyDown.whichOn - 1 : numEllipsoids - 1);
            break;
            
        // view change
        // translates / rotates the Eye and Center vectors
        case "KeyA": // translate view left, rotate left with shift
            if (inputKeys.KeyA > 0) { // if key is already pressed
                inputKeys.KeyA = 1;
            }
            else {
                inputKeys.KeyA = 2;
            }

            //Center = vec3.add(Center, Center, vec3.scale(temp, viewRight, -viewDelta));
            //if (!event.getModifierState("Shift"))
            //    Eye = vec3.add(Eye,Eye,vec3.scale(temp,viewRight,-viewDelta));
            break;
        case "KeyD": // translate view right, rotate right with shift
            if (inputKeys.KeyD > 0) { // if key is already pressed
                inputKeys.KeyD = 1;
            }
            else {
                inputKeys.KeyD = 2;
            }

            //Center = vec3.add(Center, Center, vec3.scale(temp, viewRight, viewDelta));
            //if (!event.getModifierState("Shift"))
            //    Eye = vec3.add(Eye,Eye,vec3.scale(temp,viewRight,viewDelta));
            break;
        case "KeyS": // translate view backward, rotate up with shift
            if (inputKeys.KeyS > 0) { // if key is already pressed
                inputKeys.KeyS = 1;
            }
            else {
                inputKeys.KeyS = 2;
            }
            //if (event.getModifierState("Shift")) {
            //    Center = vec3.add(Center,Center,vec3.scale(temp,Up,-viewDelta));
            //    Up = vec3.cross(Up,viewRight,vec3.subtract(lookAt,Center,Eye)); /* global side effect */
            //} else {
            //    Eye = vec3.add(Eye,Eye,vec3.scale(temp,lookAt,-viewDelta));
            //    Center = vec3.add(Center,Center,vec3.scale(temp,lookAt,-viewDelta));
            //} // end if shift not pressed
            break;
        case "KeyW": // translate view forward, rotate down with shift
            if (inputKeys.KeyW > 0) { // if key is already pressed
                inputKeys.KeyW = 1;
            }
            else {
                inputKeys.KeyW = 2;
            }

            //if (event.getModifierState("Shift")) {
            //    Center = vec3.add(Center,Center,vec3.scale(temp,Up,viewDelta));
            //    Up = vec3.cross(Up,viewRight,vec3.subtract(lookAt,Center,Eye)); /* global side effect */
            //} else {
            //    Eye = vec3.add(Eye,Eye,vec3.scale(temp,lookAt,viewDelta));
            //    Center = vec3.add(Center,Center,vec3.scale(temp,lookAt,viewDelta));
            //} // end if shift not pressed
            break;
        case "KeyQ": // translate view up, rotate counterclockwise with shift
            if (inputKeys.KeyQ > 0) { // if key is already pressed
                inputKeys.KeyQ = 1;
            }
            else {
                inputKeys.KeyQ = 2;
            }

            //if (event.getModifierState("Shift"))
            //    Up = vec3.normalize(Up,vec3.add(Up,Up,vec3.scale(temp,viewRight,-viewDelta)));
            //else {
            //    Eye = vec3.add(Eye,Eye,vec3.scale(temp,Up,viewDelta));
            //    Center = vec3.add(Center,Center,vec3.scale(temp,Up,viewDelta));
            //} // end if shift not pressed
            break;
        case "KeyE": // translate view down, rotate clockwise with shift
            if (inputKeys.KeyE > 0) { // if key is already pressed
                inputKeys.KeyE = 1;
            }
            else {
                inputKeys.KeyE = 2;
            }

            //if (event.getModifierState("Shift"))
            //    Up = vec3.normalize(Up,vec3.add(Up,Up,vec3.scale(temp,viewRight,viewDelta)));
            //else {
            //    Eye = vec3.add(Eye,Eye,vec3.scale(temp,Up,-viewDelta));
            //    Center = vec3.add(Center,Center,vec3.scale(temp,Up,-viewDelta));
            //} // end if shift not pressed
            break;
        case "Escape": // reset view to default
            if (inputKeys.Escape > 0) { // if key is already pressed
                inputKeys.Escape = 1;
            }
            else {
                inputKeys.Escape = 2;
            }

            //Eye = vec3.copy(Eye, defaultEye);
            //Center = vec3.copy(Center,defaultCenter);
            //Up = vec3.copy(Up,defaultUp);
            break;
        case "KeyB": // toggles the lighting & blending mode
            if (inputKeys.KeyB > 0) { // if key is already pressed
                inputKeys.KeyB = 1;
            }
            else {
                inputKeys.KeyB = 2;
            }

            //toggleBlendingLightingMode = !toggleBlendingLightingMode;
            break;
        case "Digit1": // toggle custom display (when shift is pressed to)
            if (inputKeys.Digit1 > 0) { // if key is already pressed
                inputKeys.Digit1 = 1;
            }
            else {
                inputKeys.Digit1 = 2;
            }

            //if (event.getModifierState("Shift")) {
            //    useCustomInput = !useCustomInput; // toggle custom mode
            //    loadModels(); // load in the models from tri fil
            //}
            break;
            
        // model transformation
        case "KeyK": // translate left, rotate left with shift
            if (inputKeys.KeyK > 0) { // if key is already pressed
                inputKeys.KeyK = 1;
            }
            else {
                inputKeys.KeyK = 2;
            }

            //if (event.getModifierState("Shift"))
            //    rotateModel(handleKeyDown.modelOn, Up, (dirEnum.NEGATIVE * rotateTheta));
            //else
            //    translateModel(handleKeyDown.modelOn, vec3.scale(temp,viewRight,-viewDelta));
            break;
        case "Semicolon": // translate right, rotate right with shift
            if (inputKeys.Semicolon > 0) { // if key is already pressed
                inputKeys.Semicolon = 1;
            }
            else {
                inputKeys.Semicolon = 2;
            }

            //if (event.getModifierState("Shift"))
            //    rotateModel(handleKeyDown.modelOn, Up, (dirEnum.POSITIVE * rotateTheta));
            //else
            //    translateModel(handleKeyDown.modelOn, vec3.scale(temp,viewRight,viewDelta));
            break;
        case "KeyL": // translate backward, rotate up with shift
            if (inputKeys.KeyL > 0) { // if key is already pressed
                inputKeys.KeyL = 1;
            }
            else {
                inputKeys.KeyL = 2;
            }

            //if (event.getModifierState("Shift"))
            //    rotateModel(handleKeyDown.modelOn, viewRight, (dirEnum.POSITIVE * rotateTheta));
            //else
            //    translateModel(handleKeyDown.modelOn, vec3.scale(temp,lookAt,-viewDelta));
            break;
        case "KeyO": // translate forward, rotate down with shift
            if (inputKeys.KeyO > 0) { // if key is already pressed
                inputKeys.KeyO = 1;
            }
            else {
                inputKeys.KeyO = 2;
            }

            //if (event.getModifierState("Shift"))
            //    rotateModel(handleKeyDown.modelOn, viewRight, (dirEnum.NEGATIVE * rotateTheta));
            //else
            //    translateModel(handleKeyDown.modelOn, vec3.scale(temp,lookAt,viewDelta));
            break;
        case "KeyI": // translate up, rotate counterclockwise with shift 
            if (inputKeys.KeyI > 0) { // if key is already pressed
                inputKeys.KeyI = 1;
            }
            else {
                inputKeys.KeyI = 2;
            }

            //if (event.getModifierState("Shift"))
            //    rotateModel(handleKeyDown.modelOn, lookAt, (dirEnum.POSITIVE * rotateTheta));
            //else
            //    translateModel(handleKeyDown.modelOn, vec3.scale(temp,Up,viewDelta));
            break;
        case "KeyP": // translate down, rotate clockwise with shift
            if (inputKeys.KeyP > 0) { // if key is already pressed
                inputKeys.KeyP = 1;
            }
            else {
                inputKeys.KeyP = 2;
            }

            //if (event.getModifierState("Shift"))
            //    rotateModel(handleKeyDown.modelOn, lookAt, (dirEnum.NEGATIVE * rotateTheta));
            //else
            //    translateModel(handleKeyDown.modelOn, vec3.scale(temp,Up,-viewDelta));
            break;
        case "Backspace": // reset model transforms to default
            if (inputKeys.Backspace > 0) { // if key is already pressed
                inputKeys.Backspace = 1;
            }
            else {
                inputKeys.Backspace = 2;
            }

            //for (var whichTriSet = 0; whichTriSet < numTriangleSets; whichTriSet++) {
            //    vec3.set(inputTriangles[whichTriSet].translation,0,0,0);
            //    vec3.set(inputTriangles[whichTriSet].xAxis,1,0,0);
            //    vec3.set(inputTriangles[whichTriSet].yAxis,0,1,0);
            //} // end for all triangle sets
            //for (var whichEllipsoid=0; whichEllipsoid<numEllipsoids; whichEllipsoid++) {
            //    vec3.set(inputEllipsoids[whichEllipsoid].translation,0,0,0);
            //    vec3.set(inputEllipsoids[whichTriSet].xAxis,1,0,0);
            //    vec3.set(inputEllipsoids[whichTriSet].yAxis,0,1,0);
            //} // end for all ellipsoids
            break;
        case "Minus":
            if (inputKeys.Minus > 0) { // if key is already pressed
                inputKeys.Minus = 1;
            }
            else {
                inputKeys.Minus = 2;
            }
            break;
        case "Equal":
            if (inputKeys.Equal > 0) { // if key is already pressed
                inputKeys.Equal = 1;
            }
            else {
                inputKeys.Equal = 2;
            }
            break;
    } // end switch
} // end handleKeyDown

/** 
 * Does stuff when keys are un-pressed
 */
function handleKeyUp(event) {

    switch (event.code) {

        // model selection
        case "Space":
            inputKeys.Space = 0;
            break;
        case "Shift":
            inputKeys.Shift = 0;
            break;
        case "ArrowRight": // deselect next triangle set
            inputKeys.ArrowRight = 0;
            break;
        case "ArrowLeft": // deselect previous triangle set
            inputKeys.ArrowLeft = 0;
            break;
        case "ArrowUp": // deselect next ellipsoid
            inputKeys.ArrowUp = 0;
            break;
        case "ArrowDown": // deselect previous ellipsoid
            inputKeys.ArrowDown = 0;
            break;

        // view change
        case "KeyA": // 
            inputKeys.KeyA = 0;
            break;
        case "KeyD": // 
            inputKeys.KeyD = 0;
            break;
        case "KeyS": // 
            inputKeys.KeyS = 0;
            break;
        case "KeyW": // 
            inputKeys.KeyW = 0;
            break;
        case "KeyQ": // translate view up, rotate counterclockwise with shift
            inputKeys.KeyQ = 0;
            break;
        case "KeyE": // translate view down, rotate clockwise with shift
            inputKeys.KeyE = 0;
            break;
        case "Escape": // reset view to default
            inputKeys.Escape = 0;
            break;
        case "KeyB": // toggles the lighting & blending mode
            inputKeys.KeyB = 0;
            break;
        case "Digit1": // toggle custom displa
            inputKeys.Digit1 = 0;
            break;

        // model transformation
        case "KeyK": // translate left, rotate left with shift
            inputKeys.KeyK = 0;
            break;
        case "Semicolon": // translate right, rotate right with shift
            inputKeys.Semicolon = 0;
            break;
        case "KeyL": // translate backward, rotate up with shift
            inputKeys.KeyL = 0;
            break;
        case "KeyO": // translate forward, rotate down with shift
            inputKeys.KeyO = 0;
            break;
        case "KeyI": // translate up, rotate counterclockwise with shift
            inputKeys.KeyI = 0;
            break;
        case "KeyP": // translate down, rotate clockwise with shift
            inputKeys.KeyP = 0;
            break;
        case "Backspace": // reset model transforms to default
            inputKeys.Backspace = 0;
            break;
        case "Minus":
            inputKeys.Minus = 0;
            break;
        case "Equal":
            inputKeys.Equal = 0;
            break;

    } // end switch
} // end handleKeyUp

/**
 * Checks for what inputs are active and acts on them.
 */
function inputUpdate() {
    const modelEnum = { TRIANGLES: "triangles", ELLIPSOID: "ellipsoid" }; // enumerated model type
    const dirEnum = { NEGATIVE: -1, POSITIVE: 1 }; // enumerated rotation direction

    // set up needed view params
    var lookAt = vec3.create(), viewRight = vec3.create(), temp = vec3.create(); // lookat, right & temp vectors
    var worldRight = vec3.fromValues(-1.0, 0.0, 0.0);
    lookAt = vec3.normalize(lookAt, vec3.subtract(temp, Center, Eye)); // get lookat vector
    viewRight = vec3.normalize(viewRight, vec3.cross(temp, lookAt, Up)); // get view right vector

    //var moveVector = new vec3.fromValues(0.0, 0.0, 0.0);

    if (inputKeys.Space > 0) {
        playerFire();
    }

    var projectileSpeed = 1.0;
    if (isPlayerShooting) {   // if player is shooting 
        translateModel(playerProjectiles[0], vec3.scale(temp, worldUp, viewDelta * 1.5));
        playerShootTimer += deltaTime;

        // stop moving projectile after some time
        if (playerShootTimer > 0.75) {
            playerShootTimer = 0;
            isPlayerShooting = false;
            playerProjectiles[0].visible = false;
        }
    }
    else if (playerShootTimer != 0) {
        playerShootTimer = 0;
        playerProjectiles[0].visible = false;
    }

    if (isEnemyShooting) {  // if an Enemy is shooting
        translateModel(enemyProjectiles[0], enemyShootDirection);
        enemyShootTimer += deltaTime;
        // stop moving projectile after some time
        if (enemyShootTimer > 1.15) {
            enemyShootTimer = 0;
            isEnemyShooting = false;
            enemyProjectiles[0].visible = false;
        }
    }
    else if (enemyShootTimer != 0) {
        enemyShootTimer = 0;
        enemyProjectiles[0].visible = false;
    }

    // player model movement
    if (inputKeys.ArrowRight > 0) { // ArrowRight
        if (playerModelsA[0].translation[0] > -0.6) { // if hasn't hid boarder yet
            translateModel(playerModelsA[0], vec3.scale(temp, worldRight, viewDelta));
            translateModel(playerModelsB[0], vec3.scale(temp, worldRight, viewDelta));
        }
        else {
            translateModel(playerModelsA[0], vec3.scale(temp, worldRight, -viewDelta));
            translateModel(playerModelsB[0], vec3.scale(temp, worldRight, -viewDelta));
        }

    }
    if (inputKeys.ArrowLeft > 0) {  // ArrowLeft
        if (playerModelsA[0].translation[0] < 0.6) { // if hasn't hid boarder yet
            translateModel(playerModelsA[0], vec3.scale(temp, worldRight, -viewDelta));
            translateModel(playerModelsB[0], vec3.scale(temp, worldRight, -viewDelta));
        }
        else {
            translateModel(playerModelsA[0], vec3.scale(temp, worldRight, viewDelta));
            translateModel(playerModelsB[0], vec3.scale(temp, worldRight, viewDelta));
        }
        
    }
    if (inputKeys.ArrowUp > 0 && debugMode == true) {    // ArrowUp
        //translateModel(playerModels[0], vec3.scale(temp, lookAt, viewDelta));
        translateModel(playerModelsA[0], vec3.scale(temp, worldUp, viewDelta));
    }
    if (inputKeys.ArrowDown > 0 && debugMode == true) {  // ArrowDown
        //translateModel(playerModels[0], vec3.scale(temp, lookAt, -viewDelta));
        translateModel(playerModelsA[0], vec3.scale(temp, worldUp, -viewDelta));
        //setModelPosition(playerModels[0], vec3.fromValues(0.5, 0.5, 0.5));
    }

    // misc inputs
    
    if (inputKeys.KeyA > 0 && debugMode == true) {   // KeyA
        Center = vec3.add(Center, Center, vec3.scale(temp, viewRight, -(viewDelta * deltaTime)));
        if (!(inputKeys.Shift > 0)) {
            Eye = vec3.add(Eye, Eye, vec3.scale(temp, viewRight, -(viewDelta * deltaTime)));
        }
    }
    if (inputKeys.KeyD > 0 && debugMode == true) {   // KeyD
        Center = vec3.add(Center, Center, vec3.scale(temp, viewRight, (viewDelta * deltaTime)));
        if (!(inputKeys.Shift > 0)) {
            Eye = vec3.add(Eye, Eye, vec3.scale(temp, viewRight, (viewDelta * deltaTime)));
        }
    }
    if (inputKeys.KeyS > 0 && debugMode == true) {   // KeyS
        if (inputKeys.Shift > 0) {
            Center = vec3.add(Center, Center, vec3.scale(temp, Up, -(viewDelta * deltaTime)));
            Up = vec3.cross(Up, viewRight, vec3.subtract(lookAt, Center, Eye)); // global side effect 
        } else {
            Eye = vec3.add(Eye, Eye, vec3.scale(temp, lookAt, -(viewDelta * deltaTime)));
            Center = vec3.add(Center, Center, vec3.scale(temp, lookAt, -(viewDelta * deltaTime)));
        } 
    }
    if (inputKeys.KeyW > 0 && debugMode == true) {   // KeyW
        if (inputKeys.Shift > 0) {
            Center = vec3.add(Center, Center, vec3.scale(temp, Up, (viewDelta * deltaTime)));
            Up = vec3.cross(Up, viewRight, vec3.subtract(lookAt, Center, Eye)); // global side effect 
        } else {
            Eye = vec3.add(Eye, Eye, vec3.scale(temp, lookAt, (viewDelta * deltaTime)));
            Center = vec3.add(Center, Center, vec3.scale(temp, lookAt, (viewDelta * deltaTime)));
        }
    }
    if (inputKeys.KeyQ > 0 && debugMode == true) {   // KeyQ
        if (inputKeys.Shift > 0) {
            Up = vec3.normalize(Up, vec3.add(Up, Up, vec3.scale(temp, viewRight, -(viewDelta * deltaTime))));
        } else {
            Eye = vec3.add(Eye, Eye, vec3.scale(temp, Up, (viewDelta * deltaTime)));
            Center = vec3.add(Center, Center, vec3.scale(temp, Up, (viewDelta * deltaTime)));
        } // end if shift not pressed
    }
    if (inputKeys.KeyE > 0 && debugMode == true) {   // KeyE
        if (inputKeys.Shift > 0)
            Up = vec3.normalize(Up, vec3.add(Up, Up, vec3.scale(temp, viewRight, (viewDelta * deltaTime))));
        else {
            Eye = vec3.add(Eye, Eye, vec3.scale(temp, Up, -(viewDelta * deltaTime)));
            Center = vec3.add(Center, Center, vec3.scale(temp, Up, -(viewDelta * deltaTime)));
        } // end if shift not pressed
    }
    

    if (inputKeys.Escape == 2) { // Escape
        inputKeys.Escape = 1;
        // reset view to default
        Eye = vec3.copy(Eye, defaultEye);
        Center = vec3.copy(Center, defaultCenter);
        Up = vec3.copy(Up, defaultUp);
    }
    if (inputKeys.KeyB == 2) {   // KeyB
        inputKeys.KeyB = 1;
        // toggle lighting blend modes
        toggleBlendingLightingMode = !toggleBlendingLightingMode;
    }
    if (inputKeys.Digit1 == 2) { // Digit1
        inputKeys.Digit1 = 1;
        // toggle custom display
        if (inputKeys.Shift > 0) {
            useCustomInput = !useCustomInput; // toggle custom mode
            loadModels(); // load in the models from tri fil
        }
    }
    if (inputKeys.KeyK > 0) {   // KeyK
        if (inputKeys.Shift > 0) {
            rotateModel(handleKeyDown.modelOn, Up, (dirEnum.NEGATIVE * rotateTheta));
        } else {
            translateModel(handleKeyDown.modelOn, vec3.scale(temp, viewRight, -viewDelta));
        }
    }
    if (inputKeys.Semicolon > 0) {  // Semicolon
        if (inputKeys.Shift > 0) {
            rotateModel(handleKeyDown.modelOn, Up, (dirEnum.POSITIVE * rotateTheta));
        } else {
            translateModel(handleKeyDown.modelOn, vec3.scale(temp, viewRight, viewDelta));
        }
    }
    if (inputKeys.KeyL > 0) {   // KeyL
        if (inputKeys.Shift > 0) {
            rotateModel(handleKeyDown.modelOn, viewRight, (dirEnum.POSITIVE * rotateTheta));
        } else {
            translateModel(handleKeyDown.modelOn, vec3.scale(temp, lookAt, -viewDelta));
        }
    }
    if (inputKeys.KeyO > 0) {   // KeyO
        if (inputKeys.Shift > 0)
            rotateModel(handleKeyDown.modelOn, viewRight, (dirEnum.NEGATIVE * rotateTheta));
        else
            translateModel(handleKeyDown.modelOn, vec3.scale(temp, lookAt, viewDelta));
    }
    if (inputKeys.KeyI > 0) {   // KeyI
        if (inputKeys.Shift > 0)
            rotateModel(handleKeyDown.modelOn, lookAt, (dirEnum.POSITIVE * rotateTheta));
        else
            translateModel(handleKeyDown.modelOn, vec3.scale(temp, Up, viewDelta));
    }
    if (inputKeys.KeyP > 0) {   // KeyP
        if (inputKeys.Shift > 0)
            rotateModel(handleKeyDown.modelOn, lookAt, (dirEnum.NEGATIVE * rotateTheta));
        else
            translateModel(handleKeyDown.modelOn, vec3.scale(temp, Up, -viewDelta));
    }
    if (inputKeys.Backspace == 2) {  // BackSpace
        for (var whichTriSet = 0; whichTriSet < numTriangleSets; whichTriSet++) {
            vec3.set(inputTriangles[whichTriSet].translation, 0, 0, 0);
            vec3.set(inputTriangles[whichTriSet].xAxis, 1, 0, 0);
            vec3.set(inputTriangles[whichTriSet].yAxis, 0, 1, 0);
        } // end for all triangle sets
        for (var whichEllipsoid = 0; whichEllipsoid < numEllipsoids; whichEllipsoid++) {
            vec3.set(inputEllipsoids[whichEllipsoid].translation, 0, 0, 0);
            vec3.set(inputEllipsoids[whichTriSet].xAxis, 1, 0, 0);
            vec3.set(inputEllipsoids[whichTriSet].yAxis, 0, 1, 0);
        } // end for all ellipsoids
    }

    if (inputKeys.Minus == 2) {
        // decrease timescale
        inputKeys.Minus = 1;
        if (timeModifier - 0.1 >= 0) {
            timeModifier -= 0.1;
        }
        console.log("timeScale: " + timeModifier);
    }
    if (inputKeys.Equal == 2) {
        // increase timescale
        inputKeys.Equal = 1;
        if (timeModifier + 0.1 <= 100) {
            timeModifier += 0.1;
        }
        console.log("timeScale: " + timeModifier);
    }

    if (numEnemiesDestroyed >= 12 && !gameLost && !gameWon) {
        wonGame();
    }

}

var switchModelTimer = 0;
var useAltModel = false;
var downOffset = 0;
/**
 * Updates animations for enemies
 */
function animUpdateEnemies(rate, dT) {
    var minOffset = vec3.fromValues(-0.2, 0.0, 0.0);
    var maxOffset = vec3.fromValues(0.2, 0.0, 0.0);
    var temp = vec3.create();
    var output = vec3.create();
    //console.log("test1: " + dT);

    switchModelTimer += dT;
    // switch between alt and main model for enemy
    if (switchModelTimer > 1) {
        useAltModel = !useAltModel;
        switchModelTimer = 0;
    }

    // enemy diver chooser
    if (enemyDiverIdx < numEnemies) {
        enemyDiveTimer += dT;

        if (enemyDiveTimer >= 8 && !diveEvent) {
            // if current diverIdx is valid
            if (enemyModelsA[enemyDiverIdx].active == true && enemyModelsB[enemyDiverIdx].active == true) {
                enemyModelsA[enemyDiverIdx].isDiving = true;
                enemyModelsB[enemyDiverIdx].isDiving = true;
                enemyDiveTimer = 0;
                downOffset = 0;
                diveEvent = true;
                console.log("dive! " + enemyDiveDirection);
                
            }

            enemyDiverIdx++;
        }
    }

    if (reverseLerp == true) {
        lerpAlpha -= rate * dT;
    }
    else {
        lerpAlpha += rate * dT;
    }
    var smoothAlpha = (0.5 * Math.sin(2 * Math.PI * (lerpAlpha + 0.75)) + 0.5);
    //console.log("smoothAlpha: " + smoothAlpha);
    if (lerpAlpha >= 1 || lerpAlpha <= 0) {
        reverseLerp = !reverseLerp;
    }
    vec3.lerp(output, minOffset, maxOffset, smoothAlpha);
    //console.log("lerpAlpha: " + lerpAlpha);
    var offset = vec3.fromValues(0, 0, 0);
    var numCol = 6;
    var numRow = enemyModelsA.length / numCol;
    var idx = 0;
    // moves enemyModels by amount
    for (var i = 0; i < numRow; i++) {
        for (var j = 0; j < numCol; j++) {
            if (enemyModelsA[idx].active == true && enemyModelsB[idx].active == true) {
                // set correct model to be shown
                enemyModelsA[idx].visible = !useAltModel;
                enemyModelsB[idx].visible = useAltModel;
                


                vec3.add(offset, output, vec3.fromValues(j * -0.2, i * -0.2, 0.0));
                enemyDiveDirection = vec3.fromValues(offset[0] * 1.5, downOffset, 0.0);
                if (diveEvent && enemyModelsA[idx].isDiving == true) {   // if enemy is diving
                    if (enemyDiveTimer >= 8) {  // enemy stops diving
                        diveEvent = false;
                        actorDestroy(enemyModelsA[idx]);
                        actorDestroy(enemyModelsB[idx]);
                        enemyDiveTimer = 0;
                        numEnemiesDestroyed++;
                    }
                    else {                      // enemy continues diving
                        
                        setModelPosition(enemyModelsA[idx], vec3.add(temp, enemyDiveDirection, enemyModelsA[idx].center), true);
                        setModelPosition(enemyModelsB[idx], vec3.add(temp, enemyDiveDirection, enemyModelsB[idx].center), true);
                        downOffset += (-0.2 * dT);

                        if (!isEnemyShooting && enemyDiveTimer > 1) {
                            var tempDir = vec3.create();
                            tempDir = vec3.normalize(tempDir, vec3.add(vec3.create(), enemyDiveDirection, vec3.fromValues(0.0, -0.5, 0.0)));
                            enemyShootDirection = vec3.fromValues(tempDir[0] * -1.25, tempDir[1] * 1.25, tempDir[2]);
                            console.log("enemyShootDirection: " + enemyShootDirection);
                            enemyFire(enemyModelsA[idx]);
                            
                        }
                        
                    }
                }
                else {
                    setModelPosition(enemyModelsA[idx], vec3.add(temp, offset, enemyModelsA[idx].center), true);
                    setModelPosition(enemyModelsB[idx], vec3.add(temp, offset, enemyModelsB[idx].center), true);
                }

                // check each model to see if it's overlapping with the player projectile
                if (!useAltModel) {
                    if (checkCollisionBetween(enemyModelsA[idx], playerProjectiles[0])) {   // check for enemy on playerProjectile collision
                        console.log("enemyHitA!: " + idx);
                        actorDestroy(enemyModelsA[idx]);
                        actorDestroy(enemyModelsB[idx]);
                        numEnemiesDestroyed++;
                        
                        isPlayerShooting = false;
                        setModelPosition(playerProjectiles[0], vec3.fromValues(-10, -10, 0), true);
                    }
                    else if (checkCollisionBetween(enemyModelsA[idx], playerModelsA[0]) // check for enemy on player collision
                          || checkCollisionBetween(enemyModelsA[idx], playerModelsB[0])) {
                        console.log("yall both died!: " + idx);
                        actorDestroy(enemyModelsA[idx]);
                        actorDestroy(enemyModelsB[idx]);
                        numEnemiesDestroyed++;

                        actorDestroy(playerModelsA[0]);
                        actorDestroy(playerModelsB[0]);

                        lostgame();
                       
                    }
                }
                else {
                    if (checkCollisionBetween(enemyModelsB[idx], playerProjectiles[0])) {
                        console.log("enemyHitB!: " + idx);
                        actorDestroy(enemyModelsA[idx]);
                        actorDestroy(enemyModelsB[idx]);
                        numEnemiesDestroyed++;
                        isPlayerShooting = false;
                        setModelPosition(playerProjectiles[0], vec3.fromValues(-10, -10, 0), true);
                    }
                    else if (checkCollisionBetween(enemyModelsB[idx], playerModelsA[0]) // check for enemy on player collision
                        || checkCollisionBetween(enemyModelsB[idx], playerModelsB[0])) {
                        console.log("yall both died!: " + idx);
                        actorDestroy(enemyModelsA[idx]);
                        actorDestroy(enemyModelsB[idx]);
                        numEnemiesDestroyed++;

                        actorDestroy(playerModelsA[0]);
                        actorDestroy(playerModelsB[0]);

                        lostgame();

                    }
                }
            }

            if (checkCollisionBetween(enemyProjectiles[0], playerModelsA[0]) // check for enemyProjectile on player collision
                || checkCollisionBetween(enemyProjectiles[0], playerModelsB[0])) {
                console.log("playerHit!: " + idx);

                actorDestroy(playerModelsA[0]);
                actorDestroy(playerModelsB[0]);

                lostgame();

            }

            idx++;
        }
        
    }
}

// deactivates and hides given actor model
function actorDestroy(actor) {
    actor.active = false;
    actor.visible = false;

    if (actor.isDiving) {
        diveEvent = false;
    }
}

/**
 * called when game is won
 */
function wonGame() {
    gameWon = true;
    gameLost = false;
    console.log("you WIN!!!");
}

/**
 * called when game is lost
 */
function lostgame() {
    gameLost = true;
    gameWon = false;
    console.log("you lost :/");
}

// set up the webGL environment
function setupWebGL() {
    
    // Set up keys
    document.onkeydown = handleKeyDown; // call this when key pressed
    document.onkeyup = handleKeyUp;


    var imageCanvas = document.getElementById("myImageCanvas"); // create a 2d canvas
      var cw = imageCanvas.width, ch = imageCanvas.height; 
      imageContext = imageCanvas.getContext("2d"); 
    //  var bkgdImage = new Image(); 
    //  bkgdImage.crossOrigin = "Anonymous";
    //  bkgdImage.src = INPUT_DEFAULT_BACKGROUND_URL;
    //  bkgdImage.onload = function(){
    //      var iw = bkgdImage.width, ih = bkgdImage.height;
    //      imageContext.drawImage(bkgdImage,0,0,iw,ih,0,0,cw,ch);   
    // }

     
    // Get the canvas and context
    var canvas = document.getElementById("myWebGLCanvas"); // create a js canvas
    gl = canvas.getContext("webgl"); // get a webgl object from it
    
    try {
        if (gl == null) {
            throw "unable to create gl context -- is your browser gl ready?";
        } else {
            //gl.clearColor(0.0, 0.0, 0.0, 1.0); // use black when we clear the frame buffer
            gl.clearDepth(1.0); // use max when we clear the depth buffer
            gl.enable(gl.DEPTH_TEST); // use hidden surface removal (with zbuffering)
            gl.enable(gl.BLEND); // enable blending
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            if (enableBackFaceCull) {
                gl.enable(gl.CULL_FACE); // use face culling
                gl.cullFace(gl.BACK); // cull back facing polygons
            }
        }
    } // end tr
    catch(e) {
        console.log(e);
    } // end catch

    loadImage(INPUT_DEFAULT_BACKGROUND_URL, true); // load background image

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true) //flip textures on y

} // end setupWebGL

/**
 * 
 * uses code from: https://webglfundamentals.org/webgl/lessons/webgl-cors-permission.html
 * @param {any} img image
 * @param {any} url string texture file path
 */
function requestCORSIfNotSameOrigin(img, url) {
    if ((new URL(url, window.location.href)).origin !== window.location.origin) {
        img.crossOrigin = "Anonymous"; // ask for CORS (Cross Origin Resource Sharing) permission
        // "anonymous" = ask for permission but don't send extra info
    }
}

/**
 * Loads image at given url and returns a textureInfo object for it
 * uses code from: https://webglfundamentals.org/webgl/lessons/webgl-cors-permission.html
 * @param {any} url string texture file path
 * @param {bool} isBackGround
 * @returns textureInfo {width, height, texture, id}
 */
function loadImage(url, isBackGround) {
    try {
        if (url == String.null) {
            throw "Unable to load image file!";
        }
        else {
            ////check if this texture is already loaded
            //for (var whichTex = 0; whichTex < textures.length; whichTex++) {
            //    if (textures[whichTex].path == url) {
            //        return whichTex;
            //    }
            //}

            const tex = gl.createTexture();
            var texID = (numTextures);
            numTextures++; // increment number of textures

            // texture storage
            gl.activeTexture(gl.TEXTURE0 + texID);
            gl.bindTexture(gl.TEXTURE_2D, tex);

            gl.bindTexture(gl.TEXTURE_2D, tex);
            // Fill the texture with a 1x1 blue pixel
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                new Uint8Array([0, 0, 255, 255]));

            const img = new Image();

            //// texture wrapping & filtering
            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

            var textureInfo = {
                path: url,
                id: texID,
                width: 1,   // we don't know the size until it loads
                height: 1,
                texture: tex
            };

            var imageCanvas = document.getElementById("myImageCanvas"); // create a 2d canvas
            var cw = imageCanvas.width, ch = imageCanvas.height;
            imageContext = imageCanvas.getContext("2d");
            img.onload = function () {
                textureInfo.width = img.width;
                textureInfo.height = img.height;

                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

                // Check if dimentions are a power of 2
                if (img.width % 2 == 1 && img.height % 2 == 1) {
                    // generate Mipmap for texture
                    gl.generateMipmap(gl.TEXTURE_2D);
                }
                else {
                    // texture wrapping & filtering
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }

                if (isBackGround) {
                    imageContext.drawImage(img, 0, 0, textureInfo.width, textureInfo.height, 0, 0, cw, ch);
                }

            };
            requestCORSIfNotSameOrigin(img, url);
            img.src = url;
            textureInfo.image = img;

            // add texture to texture list
            textures.push(textureInfo);
            //console.log("path: " + url + ", texture: " + textureInfo.texture + ", id: " + textureInfo.id);

            return textureInfo;
        }
    } // end try
    catch (e) {
        console.log(e);
    } // end catch
}

function compareTriSetAlpha(a, b) {
    return b.material.alpha - a.material.alpha;
    
}

function compareEllipsoidAlpha(a, b) {
    return b.alpha - a.alpha;

}

function compareTriZDepth(a, b) {
    var temp = vec3.create(); // an intermediate vec3
    if (a.material.alpha == 1.0 || b.material.alpha == 1.0) { // ingore opaque comparisons
        return 0;
    }
    else {
        // compare distances
        var aDistance = vec3.distance(Eye, vec3.add(temp, a.center, a.translation));
        var bDistance = vec3.distance(Eye, vec3.add(temp, b.center, b.translation));

        //console.log("test1: " + aDistance + " vs " + bDistance);
        return (bDistance - aDistance);
    }
}

function compareEllipsoidZDepth(a, b) {
    if (a.alpha == 1.0 || b.alpha == 1.0) { // ingore opaque comparisons
        return 0;
    }
    else {
        // compare distances
        var aDistance = vec3.create();
        var bDistance = vec3.create();
        var temp = vec3.create(); // an intermediate vec3
        aDistance = vec3.distance(Eye, vec3.add(temp, a.center, a.translation));
        bDistance = vec3.distance(Eye, vec3.add(temp, b.center, b.translation));

        //console.log("test1: " + aDistance + " vs " + bDistance);
        return (bDistance - aDistance);
    }
}

/**
 * Check for collision between the two given objects
 * @param {any} a
 * @param {any} b
 */
function checkCollisionBetween(a, b) {
    var dist = vec3.create();
    //var temp = vec3.create(); // an intermediate vec3

    // get distance between the two
    dist = vec3.distance(vec3.add(vec3.create(), a.center, a.translation), vec3.add(vec3.create(), b.center, b.translation));

    if (dist > -0.05 && dist < 0.05) {
        console.log("hit distance: " + dist + " | " + vec3.add(vec3.create(), a.center, a.translation) + " - " + vec3.add(vec3.create(), b.center, b.translation));
        return true;
    }
    else {
        return false;
    }

}

/**
 * Read models in, load them into webgl buffers
 */
function loadModels() {
    
    // make an ellipsoid, with numLongSteps longitudes.
    // start with a sphere of radius 1 at origin
    // Returns verts, tris and normals.
    function makeEllipsoid(currEllipsoid,numLongSteps) {
        
        try {
            if (numLongSteps % 2 != 0)
                throw "in makeSphere: uneven number of longitude steps!";
            else if (numLongSteps < 4)
                throw "in makeSphere: number of longitude steps too small!";
            else { // good number longitude steps
            
                //console.log("ellipsoid xyz: "+ ellipsoid.x +" "+ ellipsoid.y +" "+ ellipsoid.z);
                
                // make vertices
                var ellipsoidVertices = [0,-1,0]; // vertices to return, init to south pole
                var angleIncr = (Math.PI+Math.PI) / numLongSteps; // angular increment 
                var latLimitAngle = angleIncr * (Math.floor(numLongSteps/4)-1); // start/end lat angle
                var latRadius, latY; // radius and Y at current latitude
                for (var latAngle=-latLimitAngle; latAngle<=latLimitAngle; latAngle+=angleIncr) {
                    latRadius = Math.cos(latAngle); // radius of current latitude
                    latY = Math.sin(latAngle); // height at current latitude
                    for (var longAngle=0; longAngle<2*Math.PI; longAngle+=angleIncr) // for each long
                        ellipsoidVertices.push(latRadius*Math.sin(longAngle),latY,latRadius*Math.cos(longAngle));
                } // end for each latitude
                ellipsoidVertices.push(0,1,0); // add north pole
                ellipsoidVertices = ellipsoidVertices.map(function(val,idx) { // position and scale ellipsoid
                    switch (idx % 3) {
                        case 0: // x
                            return(val*currEllipsoid.a+currEllipsoid.x);
                        case 1: // y
                            return(val*currEllipsoid.b+currEllipsoid.y);
                        case 2: // z
                            return(val*currEllipsoid.c+currEllipsoid.z);
                    } // end switch
                }); 

                // make normals using the ellipsoid gradient equation
                // resulting normals are unnormalized: we rely on shaders to normalize
                var ellipsoidNormals = ellipsoidVertices.slice(); // start with a copy of the transformed verts
                ellipsoidNormals = ellipsoidNormals.map(function(val,idx) { // calculate each normal
                    switch (idx % 3) {
                        case 0: // x
                            return(2/(currEllipsoid.a*currEllipsoid.a) * (val-currEllipsoid.x));
                        case 1: // y
                            return(2/(currEllipsoid.b*currEllipsoid.b) * (val-currEllipsoid.y));
                        case 2: // z
                            return(2/(currEllipsoid.c*currEllipsoid.c) * (val-currEllipsoid.z));
                    } // end switch
                }); 

                // make UVs
                var ellipsoidUVs = []; // empty list of ellipsoidUVs
                for (var idx = 0; idx < ellipsoidVertices.length; idx += 3) {
                    if (idx % 3 == 0) {
                        var temp = vec3.create();
                        var surfacePoint = vec3.fromValues(ellipsoidVertices[idx], ellipsoidVertices[idx + 1], ellipsoidVertices[idx + 2]);
                        var ellipsoidCenter = vec3.fromValues(currEllipsoid.x, currEllipsoid.y, currEllipsoid.z);
                        var n = vec3.normalize(temp, vec3.subtract(temp, surfacePoint, ellipsoidCenter));
                        var u = Math.atan2(n[0], n[2]) / (2 * Math.PI) + 0.5;
                        var v = n[1] * 0.5 + 0.5;
                        ellipsoidUVs.push(u, v);
                    }
                }
                
                // make triangles, from south pole to middle latitudes to north pole
                var ellipsoidTriangles = []; // triangles to return
                for (var whichLong=1; whichLong<numLongSteps; whichLong++) // south pole
                    ellipsoidTriangles.push(0,whichLong,whichLong+1);
                ellipsoidTriangles.push(0,numLongSteps,1); // longitude wrap tri
                var llVertex; // lower left vertex in the current quad
                for (var whichLat=0; whichLat<(numLongSteps/2 - 2); whichLat++) { // middle lats
                    for (var whichLong=0; whichLong<numLongSteps-1; whichLong++) {
                        llVertex = whichLat*numLongSteps + whichLong + 1;
                        ellipsoidTriangles.push(llVertex,llVertex+numLongSteps,llVertex+numLongSteps+1);
                        ellipsoidTriangles.push(llVertex,llVertex+numLongSteps+1,llVertex+1);
                    } // end for each longitude
                    ellipsoidTriangles.push(llVertex+1,llVertex+numLongSteps+1,llVertex+2);
                    ellipsoidTriangles.push(llVertex+1,llVertex+2,llVertex-numLongSteps+2);
                } // end for each latitude
                for (var whichLong=llVertex+2; whichLong<llVertex+numLongSteps+1; whichLong++) // north pole
                    ellipsoidTriangles.push(whichLong,ellipsoidVertices.length/3-1,whichLong+1);
                ellipsoidTriangles.push(ellipsoidVertices.length/3-2,ellipsoidVertices.length/3-1,
                                        ellipsoidVertices.length/3-numLongSteps-1); // longitude wrap
            } // end if good number longitude steps
            return({vertices:ellipsoidVertices, normals:ellipsoidNormals, uvs:ellipsoidUVs, triangles:ellipsoidTriangles});
        } // end try
        
        catch(e) {
            console.log(e);
        } // end catch
    } // end make ellipsoid

    if (useCustomInput) {
        inputTriangles = customInputTriangles;
    }
    else {
        inputTriangles = testInputTriangles;
        //inputTriangles = getJSONFile(INPUT_TRIANGLES_URL,"triangles"); // read in the triangle data

    }
    //inputTriangles = getJSONFile(INPUT_TRIANGLES_URL,"triangles"); // read in the triangle data
    
    try {
        if (inputTriangles == String.null)
            throw "Unable to load triangles file!";
        else {
            var whichSetVert; // index of vertex in current triangle set
            var whichSetTri; // index of triangle in current triangle set
            var vtxToAdd; // vtx coords to add to the coord array
            var normToAdd; // vtx normal to add to the coord array
            var uvToAdd; // vtx UV to add to the UV array
            var triToAdd; // tri indices to add to the index array
            var maxCorner = vec3.fromValues(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE); // bbox corner
            var minCorner = vec3.fromValues(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE); // other corner

            numTriangleSets = inputTriangles.length; // remember how many tri sets

            // order triangle sets by opacity
            inputTriangles.sort(compareTriSetAlpha);

            // process each triangle set to load webgl vertex and triangle buffers
            for (var whichSet=0; whichSet < numTriangleSets; whichSet++) { // for each tri set

                // set up hilighting, modeling translation and rotation
                inputTriangles[whichSet].center = new vec3.fromValues(0,0,0);  // center point of tri set
                inputTriangles[whichSet].on = false; // not highlighted
                inputTriangles[whichSet].translation = new vec3.fromValues(0,0,0); // no translation
                
                inputTriangles[whichSet].xAxis = new vec3.fromValues(1,0,0); // model X axis
                inputTriangles[whichSet].yAxis = new vec3.fromValues(0,1,0); // model Y axis 

                // set up the vertex and normal arrays, define model center and axes
                inputTriangles[whichSet].glVertices = new Array(); // flat coord list for webgl
                inputTriangles[whichSet].glNormals = new Array(); // flat normal list for webgl
                inputTriangles[whichSet].glUVs = new Array(); // flat UV list for webgl

                inputTriangles[whichSet].index = whichSet;
                if (inputTriangles[whichSet].visible == String.null) {
                    inputTriangles[whichSet].visible = true;
                }

                if (inputTriangles[whichSet].active == String.null) {
                    inputTriangles[whichSet].active = true;
                }

                var numVerts = inputTriangles[whichSet].vertices.length; // num vertices in tri set
                for (whichSetVert=0; whichSetVert<numVerts; whichSetVert++) { // verts in set
                    vtxToAdd = inputTriangles[whichSet].vertices[whichSetVert]; // get vertex to add
                    normToAdd = inputTriangles[whichSet].normals[whichSetVert]; // get normal to add
                    if (inputTriangles[whichSet].uvs[whichSetVert] == null) {
                        inputTriangles[whichSet].uvs[whichSetVert] = [0, 0];
                    }
                    uvToAdd = inputTriangles[whichSet].uvs[whichSetVert]; // get uv to add
                    inputTriangles[whichSet].glVertices.push(vtxToAdd[0],vtxToAdd[1],vtxToAdd[2]); // put coords in set coord list
                    inputTriangles[whichSet].glNormals.push(normToAdd[0], normToAdd[1], normToAdd[2]); // put normal in set coord list
                    //if (uvToAdd == null) {
                    //    uvToAdd = [0, 0];
                    //}
                    inputTriangles[whichSet].glUVs.unshift(uvToAdd[0], uvToAdd[1]); // put UV in set coord list (uses unshift to flip texture on x-axis)
                    vec3.max(maxCorner,maxCorner,vtxToAdd); // update world bounding box corner maxima
                    vec3.min(minCorner,minCorner,vtxToAdd); // update world bounding box corner minima
                    vec3.add(inputTriangles[whichSet].center,inputTriangles[whichSet].center,vtxToAdd); // add to ctr sum
                } // end for vertices in set
                vec3.scale(inputTriangles[whichSet].center,inputTriangles[whichSet].center,1/numVerts); // avg ctr sum


                // send the vertex, normal, and UV cords to webGL
                    // vertices
                vertexBuffers[whichSet] = gl.createBuffer(); // init empty webgl set vertex coord buffer
                gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffers[whichSet]); // activate that buffer
                gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(inputTriangles[whichSet].glVertices),gl.STATIC_DRAW); // data in
                    // normals
                normalBuffers[whichSet] = gl.createBuffer(); // init empty webgl set normal component buffer
                gl.bindBuffer(gl.ARRAY_BUFFER,normalBuffers[whichSet]); // activate that buffer
                gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(inputTriangles[whichSet].glNormals),gl.STATIC_DRAW); // data in
                    // UVs
                uvBuffers[whichSet] = gl.createBuffer(); // init empty webgl set UV component buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffers[whichSet]); // activate that buffer
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(inputTriangles[whichSet].glUVs), gl.STATIC_DRAW); // data in

                // set up the textureIDs for each (if any)
                if (inputTriangles[whichSet].material.texture != String.null
                        && inputTriangles[whichSet].material.texture != "") {
                    inputTriangles[whichSet].glTextureID = loadImage(INPUT_PROG_URL + inputTriangles[whichSet].material.texture, false).id;
                    //console.log("inputTriangles[" + whichSet + "].glTextureID: " + inputTriangles[whichSet].glTextureID);
                }
                else {
                    inputTriangles[whichSet].glTextureID = -1; // no texture
                }
                

                // set up the triangle index array, adjusting indices across sets
                inputTriangles[whichSet].glTriangles = []; // flat index list for webgl
                triSetSizes[whichSet] = inputTriangles[whichSet].triangles.length; // number of tris in this set
                for (whichSetTri=0; whichSetTri<triSetSizes[whichSet]; whichSetTri++) {
                    triToAdd = inputTriangles[whichSet].triangles[whichSetTri]; // get tri to add
                    inputTriangles[whichSet].glTriangles.push(triToAdd[0],triToAdd[1],triToAdd[2]); // put indices in set list
                } // end for triangles in set

                // add to object list
                //objectList.push(inputTriangles[whichSet]);
                

                // send the triangle indices to webGL
                triangleBuffers.push(gl.createBuffer()); // init empty triangle index buffer
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, triangleBuffers[whichSet]); // activate that buffer
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(inputTriangles[whichSet].glTriangles),gl.STATIC_DRAW); // data in

                
                // if the triSet has a "count", duplicate it by the given ammount
                if (inputTriangles[whichSet].count != String.null && inputTriangles[whichSet].count > 1) {
                    var enemySpacing = 20;
                    console.log("enemyCount: " + inputTriangles[whichSet].count);
                    for (var i = 1; i < inputTriangles[whichSet].count; i++) {
                            
                        // create new object in triangles list and clone enemy data into it
                        inputTriangles.push(new Object);
                        inputTriangles[numTriangleSets] = Object.assign(inputTriangles[numTriangleSets], inputTriangles[whichSet]);
                        inputTriangles[numTriangleSets].count = 1;
                        inputTriangles[numTriangleSets].active = true;
                                
                        // offset vertices
                        //for (var j = 0; j < inputTriangles[numTriangleSets].vertices.length; j++) {
                            //inputTriangles[numTriangleSets].vertices[j] = new vec3.fromValues( inputTriangles[numTriangleSets].vertices[j][0] + (i * -0.02), inputTriangles[numTriangleSets].vertices[j][1], inputTriangles[numTriangleSets].vertices[j][2]);
                            //translateModel(inputTriangles[numTriangleSets], vec3.fromValues(i * -0.20, 0, 0));
                        //}

                        console.log("Object Cloned");
                        numTriangleSets++;

                    }
                }

                // check for triangle set type special cases
                if (inputTriangles[whichSet].type != String.null) {
                    if (inputTriangles[whichSet].type == objectTypeEnum.PLAYER_A) {   // PLAYER_A
                        playerModelsA.push(inputTriangles[whichSet]);
                    }
                    else if (inputTriangles[whichSet].type == objectTypeEnum.PLAYER_B) {   // PLAYER_B
                        playerModelsB.push(inputTriangles[whichSet]);
                    }
                    else if (inputTriangles[whichSet].type == objectTypeEnum.ENEMY_A) {   // ENEMY_A
                        inputTriangles[whichSet].isDiving = false;
                        enemyModelsA.push(inputTriangles[whichSet]);
                        numEnemies++;

                    }
                    else if (inputTriangles[whichSet].type == objectTypeEnum.ENEMY_B) {   // ENEMY_B
                        inputTriangles[whichSet].isDiving = false;
                        enemyModelsB.push(inputTriangles[whichSet]);

                    }
                    else if (inputTriangles[whichSet].type == objectTypeEnum.PLAYER_PROJECTILE) {   // PLAYER_PROJECTILE
                        playerProjectiles.push(inputTriangles[whichSet]);

                    }
                    else if (inputTriangles[whichSet].type == objectTypeEnum.ENEMY_PROJECTILE) {   // ENEMY_PROJECTILE
                        enemyProjectiles.push(inputTriangles[whichSet]);

                    }
                }
                
                //inputTriangles[whichSet].velocity = vec3.fromValues(0.0, 0.0, 0.0);
                numObjects++;
            } // end for each triangle set

            inputEllipsoids = getJSONFile(INPUT_ELLIPSOIDS_URL,"ellipsoids"); // read in the ellipsoids

            if (inputEllipsoids == String.null)
                throw "Unable to load ellipsoids file!";
            else {

                // sort ellipsoids by alpha
                inputEllipsoids.sort(compareEllipsoidAlpha);

                // init ellipsoid highlighting, translation and rotation; update bbox
                var ellipsoid; // current ellipsoid
                var ellipsoidModel; // current ellipsoid triangular model
                var temp = vec3.create(); // an intermediate vec3
                var minXYZ = vec3.create(), maxXYZ = vec3.create();  // min/max xyz from ellipsoid
                numEllipsoids = inputEllipsoids.length; // remember how many ellipsoids
                for (var whichEllipsoid=0; whichEllipsoid<numEllipsoids; whichEllipsoid++) {
                    
                    // set up various stats and transforms for this ellipsoid
                    ellipsoid = inputEllipsoids[whichEllipsoid];
                    ellipsoid.on = false; // ellipsoids begin without highlight
                    ellipsoid.translation = vec3.fromValues(0,0,0); // ellipsoids begin without translation
                    ellipsoid.xAxis = vec3.fromValues(1,0,0); // ellipsoid X axis
                    ellipsoid.yAxis = vec3.fromValues(0,1,0); // ellipsoid Y axis 
                    ellipsoid.center = vec3.fromValues(ellipsoid.x,ellipsoid.y,ellipsoid.z); // locate ellipsoid ctr
                    vec3.set(minXYZ,ellipsoid.x-ellipsoid.a,ellipsoid.y-ellipsoid.b,ellipsoid.z-ellipsoid.c); 
                    vec3.set(maxXYZ,ellipsoid.x+ellipsoid.a,ellipsoid.y+ellipsoid.b,ellipsoid.z+ellipsoid.c); 
                    vec3.min(minCorner,minCorner,minXYZ); // update world bbox min corner
                    vec3.max(maxCorner,maxCorner,maxXYZ); // update world bbox max corner

                    // make the ellipsoid model
                    ellipsoidModel = makeEllipsoid(ellipsoid,32);
    
                    // send the ellipsoid vertex coords and normals to webGL
                    // vertices
                    vertexBuffers.push(gl.createBuffer()); // init empty webgl ellipsoid vertex coord buffer
                    gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffers[vertexBuffers.length-1]); // activate that buffer
                    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(ellipsoidModel.vertices),gl.STATIC_DRAW); // data in
                    // normals
                    normalBuffers.push(gl.createBuffer()); // init empty webgl ellipsoid vertex normal buffer
                    gl.bindBuffer(gl.ARRAY_BUFFER,normalBuffers[normalBuffers.length-1]); // activate that buffer
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ellipsoidModel.normals), gl.STATIC_DRAW); // data in
                    // UVs
                    uvBuffers.push(gl.createBuffer()); // init empty webgl ellipsoid vertex UV buffer
                    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffers[uvBuffers.length - 1]); // activate that buffer
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ellipsoidModel.uvs), gl.STATIC_DRAW); // data in

                    // set up ellipsoid textureID
                    if (ellipsoid.texture != String.null
                            && ellipsoid.texture != "") {
                        ellipsoidModel.glTextureID = loadImage(INPUT_PROG_URL + ellipsoid.texture, false).id; // has texture
                    }
                    else {
                        ellipsoidModel.glTextureID = -1; // no texture
                    }

                    triSetSizes.push(ellipsoidModel.triangles.length);
    
                    // send the triangle indices to webGL
                    triangleBuffers.push(gl.createBuffer()); // init empty triangle index buffer
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, triangleBuffers[triangleBuffers.length-1]); // activate that buffer
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(ellipsoidModel.triangles), gl.STATIC_DRAW); // data in

                    
                } // end for each ellipsoid

                // sets viewDelta based on the distance between the max and min corners
                viewDelta = vec3.length(vec3.subtract(temp, maxCorner, minCorner)) / viewDeltaModifier; // set global

            } // end if ellipsoid file loaded
        } // end if triangle file loaded
    } // end try 
    
    catch(e) {
        console.log(e);
    } // end catch
} // end load models


// setup the webGL shaders
function setupShaders() {
    
    // define vertex shader in essl using es6 template strings
    var vShaderCode = `
        attribute vec3 aVertexPosition; // vertex position
        attribute vec3 aVertexNormal; // vertex normal
        attribute vec2 aVertexUV; // vertex UV coordinate
        
        uniform mat4 umMatrix; // the model matrix
        uniform mat4 upvmMatrix; // the project view model matrix
        
        varying vec3 vWorldPos; // interpolated world position of vertex
        varying vec3 vVertexNormal; // interpolated normal for frag shader
        varying vec2 vVertexUV; // interpolated UV coordinate for frag shader

        void main(void) {
            
            // vertex position
            vec4 vWorldPos4 = umMatrix * vec4(aVertexPosition, 1.0);
            vWorldPos = vec3(vWorldPos4.x,vWorldPos4.y,vWorldPos4.z);
            gl_Position = upvmMatrix * vec4(aVertexPosition, 1.0);

            // vertex normal (assume no non-uniform scale)
            vec4 vWorldNormal4 = umMatrix * vec4(aVertexNormal, 0.0);
            vVertexNormal = normalize(vec3(vWorldNormal4.x,vWorldNormal4.y,vWorldNormal4.z));

            // vertex UV
            vVertexUV = aVertexUV;

        }
    `;
    
    // define fragment shader in essl using es6 template strings
    var fShaderCode = `
        precision mediump float; // set float to medium precision

        // eye location
        uniform vec3 uEyePosition; // the eye's position in world
        
        // light properties
        uniform vec3 uLightAmbient; // the light's ambient color
        uniform vec3 uLightDiffuse; // the light's diffuse color
        uniform vec3 uLightSpecular; // the light's specular color
        uniform vec3 uLightPosition; // the light's position
        
        // material properties
        uniform vec3 uAmbient; // the ambient reflectivity
        uniform vec3 uDiffuse; // the diffuse reflectivity
        uniform vec3 uSpecular; // the specular reflectivity
        uniform float uShininess; // the specular exponent
        uniform float uAlpha; // the alpha value
        uniform sampler2D uTextureID; // ID of texture to use
        uniform bool uHasTexture; // whether or not the shader should read the texture
        uniform bool uModulateTex; // whether or not the shader should blend texture colo with fragment color
        
        // geometry properties
        varying vec3 vWorldPos; // world xyz of fragment
        varying vec3 vVertexNormal; // normal of fragment
        varying vec2 vVertexUV; // UV of fragment
            
        void main(void) {

            // ambient term
            vec3 ambient = uAmbient * uLightAmbient;
            
            // diffuse term
            vec3 normal = normalize(vVertexNormal); 
            vec3 light = normalize(uLightPosition - vWorldPos);
            float lambert = max(0.0,dot(normal,light));
            vec3 diffuse = uDiffuse*uLightDiffuse*lambert; // diffuse term
            
            // specular term
            vec3 eye = normalize(uEyePosition - vWorldPos);
            vec3 halfVec = normalize(light+eye);
            float highlight = pow(max(0.0,dot(normal,halfVec)),uShininess);
            vec3 specular = uSpecular*uLightSpecular*highlight; // specular term

            // combine to output color
            if (uHasTexture) { // if has a texture
                vec4 texelValues = texture2D(uTextureID, vVertexUV);
                vec3 colorOut = ambient + diffuse + specular; // includes texture color
                //vec3 colorOut = vec3(texelValues.x, texelValues.y, texelValues.z); // only texture color

                if (uModulateTex){
                    gl_FragColor = texture2D(uTextureID, vVertexUV) *  vec4(colorOut, uAlpha); // blender texture and frag color
                } else {
                    gl_FragColor = texture2D(uTextureID, vVertexUV); // only texture
                }
                
            }
            else { // if no texture
                vec3 colorOut = ambient + diffuse + specular; // no specular yet

                gl_FragColor = vec4(colorOut, uAlpha); // frag color only
            }

        }
    `;
    
    try {
        var fShader = gl.createShader(gl.FRAGMENT_SHADER); // create frag shader
        gl.shaderSource(fShader,fShaderCode); // attach code to shader
        gl.compileShader(fShader); // compile the code for gpu execution

        var vShader = gl.createShader(gl.VERTEX_SHADER); // create vertex shader
        gl.shaderSource(vShader,vShaderCode); // attach code to shader
        gl.compileShader(vShader); // compile the code for gpu execution
            
        if (!gl.getShaderParameter(fShader, gl.COMPILE_STATUS)) { // bad frag shader compile
            throw "error during fragment shader compile: " + gl.getShaderInfoLog(fShader);  
            gl.deleteShader(fShader);
        } else if (!gl.getShaderParameter(vShader, gl.COMPILE_STATUS)) { // bad vertex shader compile
            throw "error during vertex shader compile: " + gl.getShaderInfoLog(vShader);  
            gl.deleteShader(vShader);
        } else { // no compile errors
            var shaderProgram = gl.createProgram(); // create the single shader program
            gl.attachShader(shaderProgram, fShader); // put frag shader in program
            gl.attachShader(shaderProgram, vShader); // put vertex shader in program
            gl.linkProgram(shaderProgram); // link program into gl context

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) { // bad program link
                throw "error during shader program linking: " + gl.getProgramInfoLog(shaderProgram);
            } else { // no shader program link errors
                gl.useProgram(shaderProgram); // activate shader program (frag and vert)
                
                // locate and enable vertex attributes
                vPosAttribLoc = gl.getAttribLocation(shaderProgram, "aVertexPosition"); // ptr to vertex pos attrib
                gl.enableVertexAttribArray(vPosAttribLoc); // connect attrib to array
                vNormAttribLoc = gl.getAttribLocation(shaderProgram, "aVertexNormal"); // ptr to vertex normal attrib
                gl.enableVertexAttribArray(vNormAttribLoc); // connect attrib to array
                vUVAttribLoc = gl.getAttribLocation(shaderProgram, "aVertexUV"); // ptr to vertex normal attrib
                gl.enableVertexAttribArray(vUVAttribLoc); // connect attrib to array
                
                // locate vertex uniforms
                mMatrixULoc = gl.getUniformLocation(shaderProgram, "umMatrix"); // ptr to mmat
                pvmMatrixULoc = gl.getUniformLocation(shaderProgram, "upvmMatrix"); // ptr to pvmmat
                
                // locate fragment uniforms
                var eyePositionULoc = gl.getUniformLocation(shaderProgram, "uEyePosition"); // ptr to eye position
                var lightAmbientULoc = gl.getUniformLocation(shaderProgram, "uLightAmbient"); // ptr to light ambient
                var lightDiffuseULoc = gl.getUniformLocation(shaderProgram, "uLightDiffuse"); // ptr to light diffuse
                var lightSpecularULoc = gl.getUniformLocation(shaderProgram, "uLightSpecular"); // ptr to light specular
                var lightPositionULoc = gl.getUniformLocation(shaderProgram, "uLightPosition"); // ptr to light position
                ambientULoc = gl.getUniformLocation(shaderProgram, "uAmbient"); // ptr to ambient
                diffuseULoc = gl.getUniformLocation(shaderProgram, "uDiffuse"); // ptr to diffuse
                specularULoc = gl.getUniformLocation(shaderProgram, "uSpecular"); // ptr to specular
                shininessULoc = gl.getUniformLocation(shaderProgram, "uShininess"); // ptr to shininess
                alphaULoc = gl.getUniformLocation(shaderProgram, "uAlpha"); // ptr to alpha
                textureIDULoc = gl.getUniformLocation(shaderProgram, "uTextureID"); // ptr to textureID
                hasTextureULoc = gl.getUniformLocation(shaderProgram, "uHasTexture"); // ptr to uHasTexture
                modulateTexULoc = gl.getUniformLocation(shaderProgram, "uModulateTex"); // ptr to uModulateTex
                
                // pass global constants into fragment uniforms
                gl.uniform3fv(eyePositionULoc,Eye); // pass in the eye's position
                gl.uniform3fv(lightAmbientULoc,lightAmbient); // pass in the light's ambient emission
                gl.uniform3fv(lightDiffuseULoc,lightDiffuse); // pass in the light's diffuse emission
                gl.uniform3fv(lightSpecularULoc,lightSpecular); // pass in the light's specular emission
                gl.uniform3fv(lightPositionULoc,lightPosition); // pass in the light's position
            } // end if no shader program link errors
        } // end if no compile errors
    } // end try 
    
    catch(e) {
        console.log(e);
    } // end catch
} // end setup shaders


/**
 * Render the loaded models.
 * Also includes render loop
 */
function renderModels(nowTime) {
    // calculate deltaTime
    nowTime *= 0.001; // converts from milliseconds to seconds
    deltaTime = (nowTime - thenTime) * timeModifier;
    deltaTimeMS = deltaTime / 0.001;
    thenTime = nowTime;

    // sort trinagles by ZDepth
    inputTriangles.sort(compareTriZDepth);

    // check for any inputs

    inputUpdate();
    // doesnt let me use delta time for unknown reason, using 0.004 as a quick fix
    animUpdateEnemies(0.1, 0.004);
    
    // construct the model transform matrix, based on model state
    function makeModelTransform(currModel) {
        var zAxis = vec3.create(), sumRotation = mat4.create(), temp = mat4.create(), negCtr = vec3.create();

        // move the model to the origin
        mat4.fromTranslation(mMatrix,vec3.negate(negCtr,currModel.center)); 
        
        // scale for highlighting if needed
        if (currModel.on)
            mat4.multiply(mMatrix,mat4.fromScaling(temp,vec3.fromValues(1.2,1.2,1.2)),mMatrix); // S(1.2) * T(-ctr)
        
        // rotate the model to current interactive orientation
        vec3.normalize(zAxis,vec3.cross(zAxis,currModel.xAxis,currModel.yAxis)); // get the new model z axis
        mat4.set(sumRotation, // get the composite rotation
            currModel.xAxis[0], currModel.yAxis[0], zAxis[0], 0,
            currModel.xAxis[1], currModel.yAxis[1], zAxis[1], 0,
            currModel.xAxis[2], currModel.yAxis[2], zAxis[2], 0,
            0, 0,  0, 1);
        mat4.multiply(mMatrix,sumRotation,mMatrix); // R(ax) * S(1.2) * T(-ctr)
        
        // translate back to model center
        mat4.multiply(mMatrix,mat4.fromTranslation(temp,currModel.center),mMatrix); // T(ctr) * R(ax) * S(1.2) * T(-ctr)

        // translate model to current interactive orientation
        mat4.multiply(mMatrix,mat4.fromTranslation(temp,currModel.translation),mMatrix); // T(pos)*T(ctr)*R(ax)*S(1.2)*T(-ctr)
        
    } // end make model transfor

    // var hMatrix = mat4.create(); // handedness matrix
    var pMatrix = mat4.create(); // projection matrix
    var vMatrix = mat4.create(); // view matrix
    var mMatrix = mat4.create(); // model matrix
    var pvMatrix = mat4.create(); // hand * proj * view matrices
    var pvmMatrix = mat4.create(); // hand * proj * view * model matrices

    window.requestAnimationFrame(renderModels); // set up frame render callback
    
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // clear frame/depth buffers
    
    // set up projection and view
    // mat4.fromScaling(hMatrix,vec3.fromValues(-1,1,1)); // create handedness matrix
    mat4.perspective(pMatrix,0.5*Math.PI,1,0.1,10); // create projection matrix
    mat4.lookAt(vMatrix,Eye,Center,Up); // create view matrix
    mat4.multiply(pvMatrix,pvMatrix,pMatrix); // projection
    mat4.multiply(pvMatrix,pvMatrix,vMatrix); // projection * view

    

    // render each triangle set
    gl.depthMask(true);
    //console.log("triOrder: " + inputTriangles[0].material.texture + ", " + inputTriangles[1].material.texture + ", " + inputTriangles[2].material.texture);
    if (showTriangles) {
        var currSet; // the tri set and its material properties
        for (var whichTriSet = 0; whichTriSet < numTriangleSets; whichTriSet++) {
            // check visibility bool to see if this model should be rendered
            if (inputTriangles[whichTriSet].visible) {

                currSet = inputTriangles[whichTriSet];

                if (currSet.material.alpha != 1.0) {
                    gl.depthMask(false);
                }

                // make model transform, add to view project
                makeModelTransform(currSet);
                mat4.multiply(pvmMatrix, pvMatrix, mMatrix); // project * view * model
                gl.uniformMatrix4fv(mMatrixULoc, false, mMatrix); // pass in the m matrix
                gl.uniformMatrix4fv(pvmMatrixULoc, false, pvmMatrix); // pass in the hpvm matrix

                // reflectivity: feed to the fragment shader
                gl.uniform3fv(ambientULoc, currSet.material.ambient); // pass in the ambient reflectivity
                gl.uniform3fv(diffuseULoc, currSet.material.diffuse); // pass in the diffuse reflectivity
                gl.uniform3fv(specularULoc, currSet.material.specular); // pass in the specular reflectivity
                gl.uniform1f(shininessULoc, currSet.material.n); // pass in the specular exponent
                gl.uniform1f(alphaULoc, currSet.material.alpha); // pass in the alpha value
                gl.uniform1i(textureIDULoc, currSet.glTextureID); // pass in the textureID value
                gl.uniform1i(hasTextureULoc, (currSet.glTextureID >= 0)); // pass in the hasTexture value
                gl.uniform1i(modulateTexULoc, toggleBlendingLightingMode); // pass in the modulateTex value
                //console.log("| " + whichTriSet + " currSet.glTextureID: " + currSet.glTextureID);

                // vertex buffer: activate and feed into vertex shader
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffers[inputTriangles[whichTriSet].index]); // activate
                gl.vertexAttribPointer(vPosAttribLoc, 3, gl.FLOAT, false, 0, 0); // feed
                // normal buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffers[inputTriangles[whichTriSet].index]); // activate
                gl.vertexAttribPointer(vNormAttribLoc, 3, gl.FLOAT, false, 0, 0); // feed
                // UV buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffers[inputTriangles[whichTriSet].index]); // activate
                gl.vertexAttribPointer(vUVAttribLoc, 2, gl.FLOAT, false, 0, 0); // feed

                // triangle buffer: activate and render
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, triangleBuffers[inputTriangles[whichTriSet].index]); // activate
                gl.drawElements(gl.TRIANGLES, 3 * triSetSizes[inputTriangles[whichTriSet].index], gl.UNSIGNED_SHORT, 0); // render
            }
        } // end for each triangle set
    }

    // render each ellipsoid
    gl.depthMask(true);
    if (showEllispoids) {
        var ellipsoid, instanceTransform = mat4.create(); // the current ellipsoid and material

        for (var whichEllipsoid = 0; whichEllipsoid < numEllipsoids; whichEllipsoid++) {
            ellipsoid = inputEllipsoids[whichEllipsoid];

            if (ellipsoid.alpha != 1.0) {
                gl.depthMask(false);
            }

            // define model transform, premult with pvmMatrix, feed to vertex shader
            makeModelTransform(ellipsoid);
            pvmMatrix = mat4.multiply(pvmMatrix, pvMatrix, mMatrix); // premultiply with pv matrix
            gl.uniformMatrix4fv(mMatrixULoc, false, mMatrix); // pass in model matrix
            gl.uniformMatrix4fv(pvmMatrixULoc, false, pvmMatrix); // pass in project view model matrix

            // reflectivity: feed to the fragment shader
            gl.uniform3fv(ambientULoc, ellipsoid.ambient); // pass in the ambient reflectivity
            gl.uniform3fv(diffuseULoc, ellipsoid.diffuse); // pass in the diffuse reflectivity
            gl.uniform3fv(specularULoc, ellipsoid.specular); // pass in the specular reflectivity
            gl.uniform1f(shininessULoc, ellipsoid.n); // pass in the specular exponent
            gl.uniform1f(alphaULoc, ellipsoid.alpha); // pass in the alpha value
            gl.uniform1i(textureIDULoc, ellipsoid.glTextureID); // pass in the textureID value
            gl.uniform1i(hasTextureULoc, (ellipsoid.glTextureID >= 0)); // pass in the hasTexture value
            gl.uniform1i(modulateTexULoc, toggleBlendingLightingMode); // pass in the hasTexture value

            // vertex bufffer
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffers[numTriangleSets + whichEllipsoid]); // activate vertex buffer
            gl.vertexAttribPointer(vPosAttribLoc, 3, gl.FLOAT, false, 0, 0); // feed vertex buffer to shader
            // normal buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffers[numTriangleSets + whichEllipsoid]); // activate normal buffer
            gl.vertexAttribPointer(vNormAttribLoc, 3, gl.FLOAT, false, 0, 0); // feed normal buffer to shader
            // UV buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffers[numTriangleSets + whichEllipsoid]); // activate UV buffer
            gl.vertexAttribPointer(vUVAttribLoc, 2, gl.FLOAT, false, 0, 0); // feed UV buffer to shader

            // triangle buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, triangleBuffers[numTriangleSets + whichEllipsoid]); // activate tri buffer

            // draw a transformed instance of the ellipsoid
            gl.drawElements(gl.TRIANGLES, triSetSizes[numTriangleSets + whichEllipsoid], gl.UNSIGNED_SHORT, 0); // render
        } // end for each ellipsoid
    }
} // end render model

/* MAIN -- HERE is where execution begins after window load */

function main() {
  setupWebGL(); // set up the webGL environment
  loadModels(); // load in the models from tri file
  setupShaders(); // setup the webGL shaders
  renderModels(); // draw the triangles using webGL
  //console.log("numEllipsoids: " + numEllipsoids);
  //console.log("numTextures: " + numTextures);

    //setModelPosition(enemyModels[0], vec3.fromValues(0.5, 0.5, 0.5));
    //setModelPosition(enemyModels[1], vec3.fromValues(0.25, 0.25, 0.25));
} // end main
